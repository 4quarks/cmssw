commit 7db8fe127432918eb0cda763c74de9c1844d08f6
Author: David <dnash@cern.ch>
Date:   Thu Feb 12 20:06:17 2015 +0100

    Another commit, still in debugging progress

diff --git a/DataFormats/MuonDetId/interface/ME0DetId.h~ b/DataFormats/MuonDetId/interface/ME0DetId.h~
deleted file mode 100644
index bedea19..0000000
--- a/DataFormats/MuonDetId/interface/ME0DetId.h~
+++ /dev/null
@@ -1,132 +0,0 @@
-#ifndef MuonDetId_ME0DetId_h
-#define MuonDetId_ME0DetId_h
-
-/** \class ME0DetId
- * 
- *  DetUnit identifier for ME0s
- *
- */
-
-#include <DataFormats/DetId/interface/DetId.h>
-#include <FWCore/Utilities/interface/Exception.h>
-
-#include <iosfwd>
-#include <iostream>
-
-class ME0DetId :public DetId {
-  
- public:
-      
-  ME0DetId();
-
-  /// Construct from a packed id. It is required that the Detector part of
-  /// id is Muon and the SubDet part is ME0, otherwise an exception is thrown.
-  ME0DetId(uint32_t id);
-  ME0DetId(DetId id);
-
-
-  /// Construct from fully qualified identifier.
-  ME0DetId(int region, 
-	   int layer,
-	   int chamber,
-	   int roll);
-	   
-
-  /// Sort Operator based on the raw detector id
-  bool operator < (const ME0DetId& r) const{
-    if (this->layer() ==  r.layer()  ){
-      return this->rawId()<r.rawId();
-    }
-    else{
-      return (this->layer() >  r.layer());
-    }
-  }
-
-  /// Region id: 0 for Barrel Not in use, +/-1 For +/- Endcap
-  int region() const{
-    return int((id_>>RegionStartBit_) & RegionMask_) + minRegionId;
-  }
-
-  /// Layer id: each station have two layers of chambers: layer 1 is the inner chamber and layer 6 is the outer chamber 
-  int layer() const{
-    //FIXME a hack, removing the "+minLayerId", to allow for 0 layer id
-    return int((id_>>LayerStartBit_) & LayerMask_) + minLayerId;
-    //return int((id_>>LayerStartBit_) & LayerMask_);
-  }
-
-  /// Chamber id: it identifies a chamber in a ring it goes from 1 to 36 
-  int chamber() const{
-    return int((id_>>ChamberStartBit_) & ChamberMask_)+minChamberId;
-    //FIXME a hack to force the chamber counting to start at 1, rather than the 0 listed for minchamber id
-    //return int((id_>>ChamberStartBit_) & ChamberMask_)-1;
-  }
-
- /// Roll id  (also known as eta partition): each chamber is divided along the strip direction in  
- /// several parts  (rolls) ME0 up to 10
-  int roll() const{
-    return int((id_>>RollStartBit_) & RollMask_) + minRollId; // value 0 is used as wild card
-  }
-
-
-  /// Return the corresponding ChamberId
-  ME0DetId chamberId() const {
-    return ME0DetId(id_ & chamberIdMask_);
-  }
-
-  static const int minRegionId=     -1;
-  static const int maxRegionId=      1;
- 
-  static const int minChamberId=     0;
-  //static const int maxChamberId=     36;
-  static const int maxChamberId=     18;
-
-  static const int minLayerId=     0;
-  //static const int minLayerId=     1;
-  static const int maxLayerId=    6;
-
-  static const int minRollId=	  0;
-  static const int maxRollId=	 1;
-
- private:
-  static const int RegionNumBits_  =  2;
-  static const int RegionStartBit_ =  0;  
-  static const int RegionMask_     =  0X3;
-
-  static const int ChamberNumBits_  =  6;
-  static const int ChamberStartBit_ =  RegionStartBit_+RegionNumBits_;
-  static const unsigned int ChamberMask_     =  0X3F;
-
-  /* static const int ChamberNumBits_  =  5; */
-  /* static const int ChamberStartBit_ =  RegionStartBit_+RegionNumBits_;   */
-  /* static const unsigned int ChamberMask_     =  0X1F; */
-
-  /* static const int LayerNumBits_  =  5; */
-  /* static const int LayerStartBit_ =  ChamberStartBit_+ChamberNumBits_; */
-  /* static const unsigned int LayerMask_     =  0X1F; */
-
-  static const int LayerNumBits_  =  3;
-  static const int LayerStartBit_ =  ChamberStartBit_+ChamberNumBits_;
-  static const unsigned int LayerMask_     =  0X7;
-
-  static const int RollNumBits_  =  5;
-  static const int RollStartBit_ =  LayerStartBit_+LayerNumBits_;
-  static const unsigned int RollMask_     =  0X1F;
-
-  /* static const int RollNumBits_  =  2; */
-  /* static const int RollStartBit_ =  LayerStartBit_+LayerNumBits_;   */
-  /* static const unsigned int RollMask_     =  0X3; */
- 
-  static const uint32_t chamberIdMask_ = ~(RollMask_<<RollStartBit_);
-
- private:
-  void init(int region, 
-	    int layer,
-	    int chamber,
-	    int roll);
-  
-  int trind;
-}; // ME0DetId
-
-std::ostream& operator<<( std::ostream& os, const ME0DetId& id );
-
-#endif
diff --git a/DataFormats/MuonDetId/src/ME0DetId.cc~ b/DataFormats/MuonDetId/src/ME0DetId.cc~
deleted file mode 100644
index 10e7b52..0000000
--- a/DataFormats/MuonDetId/src/ME0DetId.cc~
+++ /dev/null
@@ -1,79 +0,0 @@
-/** \file
- * Impl of ME0DetId
- */
-
-#include <DataFormats/MuonDetId/interface/ME0DetId.h>
-#include <DataFormats/MuonDetId/interface/MuonSubdetId.h> 
-
-ME0DetId::ME0DetId():DetId(DetId::Muon, MuonSubdetId::ME0){}
-
-
-ME0DetId::ME0DetId(uint32_t id):DetId(id){
-  if (det()!=DetId::Muon || subdetId()!=MuonSubdetId::ME0) {
-    throw cms::Exception("InvalidDetId") << "ME0DetId ctor:"
-					 << " det: " << det()
-					 << " subdet: " << subdetId()
-					 << " is not a valid ME0 id";  
-  }
-}
-
-ME0DetId::ME0DetId(DetId id):DetId(id) {
-  if (det()!=DetId::Muon || subdetId()!=MuonSubdetId::ME0) {
-    throw cms::Exception("InvalidDetId") << "ME0DetId ctor:"
-					 << " det: " << det()
-					 << " subdet: " << subdetId()
-					 << " is not a valid ME0 id";  
-  }
-}
-
-ME0DetId::ME0DetId(int region, int layer,int chamber, int roll):	      
-  DetId(DetId::Muon, MuonSubdetId::ME0)
-{
-  this->init(region,layer,chamber,roll);
-}
-
-void
-ME0DetId::init(int region,int layer,int chamber,int roll)
-{
-  if ( region     < minRegionId    || region    > maxRegionId ||
-       //layer      < minLayerId     || layer     > maxLayerId ||
-       layer      < 0     || layer     > maxLayerId ||
-       chamber    < minChamberId   || chamber   > maxChamberId ||
-       roll       < minRollId      || roll      > maxRollId) {
-    throw cms::Exception("InvalidDetId") << "ME0DetId ctor:" 
-					 << " Invalid parameters: " 
-					 << " region "<<region
-					 << " layer "<<layer
-					 << " chamber "<<chamber
-					 << " etaPartition "<<roll
-					 << std::endl;
-  }
-  int regionInBits=region-minRegionId;
-  //FIXME hacking it so the minlayer is effectively zero, allowing us to store a zero
-  int layerInBits=layer-minLayerId;
-  //int layerInBits=layer-0;
-  int chamberInBits=chamber-minChamberId;
-  int rollInBits=roll-minRollId;
-  
-  id_ |= ( regionInBits    & RegionMask_)    << RegionStartBit_    | 
-         ( layerInBits     & LayerMask_)     << LayerStartBit_     |
-         ( chamberInBits   & ChamberMask_)    << ChamberStartBit_  |
-         ( rollInBits      & RollMask_)      << RollStartBit_        ;
-   
-}
-
-
-
-std::ostream& operator<<( std::ostream& os, const ME0DetId& id ){
-
-
-  os <<  " Region "<<id.region()
-     << " Layer "<<id.layer()
-     << " Chamber "<<id.chamber()
-     << " EtaPartition "<<id.roll()
-     <<" ";
-
-  return os;
-}
-
-
diff --git a/Geometry/CSCGeometryBuilder/src/CSCGeometryBuilder.cc~ b/Geometry/CSCGeometryBuilder/src/CSCGeometryBuilder.cc~
deleted file mode 100644
index 0eeb86f..0000000
--- a/Geometry/CSCGeometryBuilder/src/CSCGeometryBuilder.cc~
+++ /dev/null
@@ -1,345 +0,0 @@
-#include "CSCGeometryBuilder.h"
-//#include <CondFormats/GeometryObjects/interface/CSCRecoDigiParameters.h>
-//#include <CondFormats/GeometryObjects/interface/RecoIdealGeometry.h>
-
-#include <Geometry/CSCGeometry/interface/CSCGeometry.h>
-
-#include <DataFormats/DetId/interface/DetId.h>
-#include <DataFormats/MuonDetId/interface/CSCDetId.h>
-#include <Geometry/CSCGeometry/src/CSCWireGroupPackage.h>
-
-#include <FWCore/MessageLogger/interface/MessageLogger.h>
-
-#include <iostream>
-#include <iomanip>
-#include <algorithm>
-#include <vector>
-
-CSCGeometryBuilder::CSCGeometryBuilder() : myName("CSCGeometryBuilder"){}
-
-
-CSCGeometryBuilder::~CSCGeometryBuilder(){}
-
-
-void CSCGeometryBuilder::build( boost::shared_ptr<CSCGeometry> theGeometry
-				, const RecoIdealGeometry& rig
-				, const CSCRecoDigiParameters& cscpars ) {
-
-  //  CSCGeometry* theGeometry = new CSCGeometry;
-
-  std::vector<float> fpar;
-  std::vector<float> gtran;
-  std::vector<float> grmat;
-  std::vector<float> fupar;
-  std::vector<double>::const_iterator it, endIt;
-  const std::vector<DetId>& detids(rig.detIds());
-
-  for ( size_t idt = 0; idt < detids.size(); ++idt) {
-    CSCDetId detid = CSCDetId( detids[idt] );
-    //    int jendcap  = detid.endcap();
-    int jstation = detid.station();
-    int jring    = detid.ring();
-    //    int jchamber = detid.chamber();
-
-    endIt = rig.shapeEnd(idt);
-    fpar.clear();
-    for ( it = rig.shapeStart(idt); it != endIt; ++it) {
-      fpar.push_back( (float)(*it) );
-    }
-
-    gtran.clear();
-    endIt = rig.tranEnd(idt);
-    for ( it = rig.tranStart(idt); it != endIt; ++it ) {
-      gtran.push_back((float)(*it));
-    }
-    grmat.clear();
-    endIt = rig.rotEnd(idt);
-    for ( it = rig.rotStart(idt) ; it != endIt; ++it ) {
-      grmat.push_back((float)(*it));
-    }
-
-    // get the chamber type from existing info
-    int chamberType = CSCChamberSpecs::whatChamberType( jstation, jring );
-    //    std::cout << "Chamber type = " << chamberType << std::endl;
-    size_t cs = 0;
-    //       assert ( cscpars.pCSCDetIds.size() != 0 );
-    assert ( cscpars.pChamberType.size() != 0 );
-    //       while (cs < cscpars.pCSCDetIds.size() && detid != cscpars.pCSCDetIds[cs]) {
-    while (cs < cscpars.pChamberType.size() && chamberType != cscpars.pChamberType[cs]) {
-      ++cs;
-    }
-    //       assert ( cs != cscpars.pCSCDetIds.size() );
-    assert ( cs != cscpars.pChamberType.size() );
-      
-    // check the existence of the specs for this type WHY? Remove it...
-    //    const CSCChamberSpecs* aSpecs = theGeometry->findSpecs( chamberType );
-    size_t fu, numfuPars;
-    CSCWireGroupPackage wg;
-    fu = cscpars.pUserParOffset[cs];
-    numfuPars = fu + 1 + size_t(cscpars.pfupars[fu]);
-
-    // upars from db are now uparvals + wg info so we need to unwrap only part here first...
-    std::cout << myName << ": I think I have " << cscpars.pUserParSize[cs] << " values in pfupars (uparvals)." << std::endl;
-    std::cout << myName << ": For fupar I will start at " << cscpars.pUserParOffset[cs] + 1 
-		     << " in pfupars and go to " << numfuPars << "." << std::endl;
-    //    if ( aSpecs == 0 ) { 
-      for ( ++fu; fu < numfuPars; ++fu ) {
-	std::cout << myName << ": pfupars[" << fu << "]=" << cscpars.pfupars[fu] << std::endl;
-	fupar.push_back(cscpars.pfupars[fu]);
-      }
-//     } else {
-//       fu = fu + numfuPars + 1;
-//     }
-    // now, we need to start from "here" at fu to go on and build wg...
-    wg.wireSpacing = cscpars.pfupars[fu++];
-    wg.alignmentPinToFirstWire = cscpars.pfupars[fu++];
-    wg.numberOfGroups = int(cscpars.pfupars[fu++]);
-    wg.narrowWidthOfWirePlane = cscpars.pfupars[fu++];
-    wg.wideWidthOfWirePlane = cscpars.pfupars[fu++];
-    wg.lengthOfWirePlane = cscpars.pfupars[fu++];
-    size_t numgrp = static_cast<size_t>(cscpars.pfupars[fu]);
-    size_t maxFu = fu + 1 + numgrp;
-    fu++;
-    for ( ;fu < maxFu; ++fu ) {
-      wg.wiresInEachGroup.push_back(int(cscpars.pfupars[fu]));
-    } 
-    maxFu = fu + numgrp;
-    //stupid comment    // MEC: 2008-04-30: decided I need to have wg every time unless whole wg idea is re-worked.
-    //       std::cout << " fu = " << fu << " going to maxFu = " << maxFu << std::endl;
-    for ( ;fu < maxFu; ++fu ) {
-      wg.consecutiveGroups.push_back(int(cscpars.pfupars[fu]));
-    } 
-          
-    if ( wg.numberOfGroups != 0 ) {
-      std::cout << myName  << ": TotNumWireGroups     = " << wg.numberOfGroups  << std::endl;
-      std::cout << myName  << ": WireSpacing          = " << wg.wireSpacing  << std::endl;
-      std::cout << myName  << ": AlignmentPinToFirstWire = " << wg.alignmentPinToFirstWire  << std::endl;
-      std::cout << myName  << ": Narrow width of wire plane = " << wg.narrowWidthOfWirePlane  << std::endl;
-      std::cout << myName  << ": Wide width of wire plane = " << wg.wideWidthOfWirePlane  << std::endl;
-      std::cout << myName  << ": Length in y of wire plane = " << wg.lengthOfWirePlane  << std::endl;
-      std::cout << myName  << ": wg.consecutiveGroups.size() = " << wg.consecutiveGroups.size()  << std::endl;
-      std::cout << myName  << ": wg.wiresInEachGroup.size() = " << wg.wiresInEachGroup.size()  << std::endl;
-      std::cout << myName  << ": \tNumGroups\tWiresInGroup"  << std::endl;
-      for (size_t i = 0; i < wg.consecutiveGroups.size(); i++) {
-	std::cout << myName  << " \t" << wg.consecutiveGroups[i] << "\t\t" << wg.wiresInEachGroup[i]  << std::endl;
-      }
-    } else {
-      std::cout << myName  << ": DDD is MISSING SpecPars for wire groups"  << std::endl;
-    }
-    std::cout << myName << ": end of wire group info. "  << std::endl;
-      
-    //      CSCWireGroupPackage wg = cscpars.pWGPs[cs];
-    // Are we going to apply centre-to-intersection offsets, even if values exist in the specs file?
-    if ( !theGeometry->centreTIOffsets() ) fupar[30] = 0.;  // reset to zero if flagged 'off'
-      
-    buildChamber (theGeometry, detid, fpar, fupar, gtran, grmat, wg ); //, cscpars.pWGPs[cs] );
-    fupar.clear();
-  }
-  //    return theGeometry;  
-}
-
-void CSCGeometryBuilder::buildChamber (  
-				       boost::shared_ptr<CSCGeometry> theGeometry // the geometry container
-				       , CSCDetId chamberId                         // the DetId for this chamber
-				       , const std::vector<float>& fpar           // volume parameters hB, hT. hD, hH	
-				       , const std::vector<float>& fupar          // user parameters 
-				       , const std::vector<float>& gtran          // translation vector	
-				       , const std::vector<float>& grmat          // rotation matrix
-				       , const CSCWireGroupPackage& wg            // wire group info
-				       ) {
-
-  std::cout << myName  << ": entering buildChamber"  << std::endl;
-
-  int jend   = chamberId.endcap();
-  int jstat  = chamberId.station();
-  int jring  = chamberId.ring();
-  int jch    = chamberId.chamber();
-  int jlay   = chamberId.layer();
-
-  if (jlay != 0 ) edm::LogWarning(myName) << "Error! CSCGeometryBuilderFromDDD was fed layer id = " << jlay << "\n";
-
-  const size_t kNpar = 4;
-  if ( fpar.size() != kNpar ) 
-    edm::LogError(myName) << "Error, expected npar=" 
-	      << kNpar << ", found npar=" << fpar.size() << std::endl;
-
-  std::cout << myName  << ":  E" << jend << " S" << jstat << " R" << jring <<
-    " C" << jch << " L" << jlay  << std::endl;
-  std::cout << myName  << ": npar=" << fpar.size() << " hB=" << fpar[0] 
-		  << " hT=" << fpar[1] << " hD=" << fpar[2] << " hH=" << fpar[3]  << std::endl;
-  std::cout << myName  << ": gtran[0,1,2]=" << gtran[0] << " " << gtran[1] << " " << gtran[2]  << std::endl;
-  std::cout << myName  << ": grmat[0-8]=" << grmat[0] << " " << grmat[1] << " " << grmat[2] << " "
-         << grmat[3] << " " << grmat[4] << " " << grmat[5] << " "
-		  << grmat[6] << " " << grmat[7] << " " << grmat[8]  << std::endl;
-  std::cout << myName  << ": nupar=" << fupar.size() << " upar[0]=" << fupar[0]
-		   << " upar[" << fupar.size()-1 << "]=" << fupar[fupar.size()-1] << std::endl;
-
-
-  const CSCChamber* chamber = theGeometry->chamber( chamberId );
-  if ( chamber ){
-  }
-  else { // this chamber not yet built/stored
-  
-    std::cout << myName <<": CSCChamberSpecs::build requested for ME" << jstat << jring  << std::endl;
-     int chamberType = CSCChamberSpecs::whatChamberType( jstat, jring );
-     const CSCChamberSpecs* aSpecs = theGeometry->findSpecs( chamberType );
-//     //    CSCChamberSpecs* aSpecs = CSCChamberSpecs::specs( chamberType );
-//     if ( aSpecs == 0 ) aSpecs = theGeometry->buildSpecs( chamberType, fpar, fupar, wg );
-    //                 aSpecs = CSCChamberSpecs::build( chamberType, fpar, fupar, wg );
-    if ( fupar.size() != 0 && aSpecs == 0 ) {
-      // make new one:
-      aSpecs = theGeometry->buildSpecs (chamberType, fpar, fupar, wg);
-    } else if ( fupar.size() == 0 && aSpecs == 0 ) {
-	std::cout << "SHOULD BE THROW? Error, wg and/or fupar size are 0 BUT this Chamber Spec has not been built!" << std::endl;
-    }
-//  else if (fupar.size() != 0 && aSpecs != 0 ) {
-//       std::cout << "SHOULD BE THROW? Error, a Chamber Specs was found AND still the fupar and/or wg were/was non-zero! " << std::endl;
-//     }
-
-
-   // Build a Transformation out of GEANT gtran and grmat...
-   // These are used to transform a point in the local reference frame
-   // of a subdetector to the global frame of CMS by
-   //         (grmat)^(-1)*local + (gtran)
-   // The corresponding transformation from global to local is
-   //         (grmat)*(global - gtran)
- 
-    Surface::RotationType aRot( grmat[0], grmat[1], grmat[2], 
-                                grmat[3], grmat[4], grmat[5],
-                                grmat[6], grmat[7], grmat[8] );
-
-   // This rotation from GEANT considers the detector face as the x-z plane.
-   // We want this to be the local x-y plane.
-   // Furthermore, the -z_global endcap has LH local coordinates, since it is built
-   // in GEANT as a *reflection* of the +z_global endcap.
-   // So we need to rotate, and in -z flip local x.
-
-   // aRot.rotateAxes will transform aRot in place so that it becomes
-   // applicable to the new local coordinates: detector face in x-y plane
-   // looking out along z, in either endcap.
-
-   // The interface for rotateAxes specifies 'new' X,Y,Z but the
-   // implementation deals with them as the 'old'.
-
-    Basic3DVector<float> oldX( 1., 0.,  0. );
-    Basic3DVector<float> oldY( 0., 0., -1. );
-    Basic3DVector<float> oldZ( 0., 1.,  0. );
-
-    if ( gtran[2]<0. ) oldX *= -1; 
-
-    aRot.rotateAxes( oldX, oldY, oldZ );
-      
-   // Need to know z of layers w.r.t to z of centre of chamber. 
-
-    float frameThickness     = fupar[31]/10.; // mm -> cm
-    float gapThickness       = fupar[32]/10.; // mm -> cm
-    float panelThickness     = fupar[33]/10.; // mm -> cm
-    float zAverageAGVtoAF    = fupar[34]/10.; // mm -> cm
-
-    float layerThickness = gapThickness; // consider the layer to be the gas gap
-    float layerSeparation = gapThickness + panelThickness; // centre-to-centre of neighbouring layers
-
-    float chamberThickness = 7.*panelThickness + 6.*gapThickness + 2.*frameThickness ; // chamber frame thickness
-    float hChamberThickness = chamberThickness/2.; // @@ should match value returned from DDD directly
-
-    // distAverageAGVtoAF is offset between centre of chamber (AF) and (L1+L6)/2 (average AGVs) 
-    // where AF = AluminumFrame and AGV=ActiveGasVolume (volume names in DDD).
-    // It is signed based on global z values: zc - (zl1+zl6)/2
-   
-    // Local z values w.r.t. AF...
-    //     z of wires in layer 1 = z_w1 = +/- zAverageAGVtoAF + 2.5*layerSeparation; // layer 1 is at most +ve local z
-    // The sign in '+/-' depends on relative directions of local and global z. 
-    // It is '-' if they are the same direction, and '+' if opposite directions.
-    //     z of wires in layer N   = z_wN = z_w1 - (N-1)*layerSeparation; 
-    //     z of strips in layer N  = z_sN = z_wN + gapThickness/2.; @@ BEWARE: need to check if it should be '-gapThickness/2' !
-
-    // Set dimensions of trapezoidal chamber volume 
-    // N.B. apothem is 4th in fpar but 3rd in ctor 
-
-    // hChamberThickness and fpar[2] should be the same - but using the above value at least shows
-    // how chamber structure works
-
-    //    TrapezoidalPlaneBounds* bounds =  new TrapezoidalPlaneBounds( fpar[0], fpar[1], fpar[3], fpar[2] ); 
-    TrapezoidalPlaneBounds* bounds =  new TrapezoidalPlaneBounds( fpar[0], fpar[1], fpar[3], hChamberThickness ); 
-
-   // Centre of chamber in z is specified in DDD
-    Surface::PositionType aVec( gtran[0], gtran[1], gtran[2] ); 
-
-    Plane::PlanePointer plane = Plane::build(aVec, aRot, bounds); 
-
-    CSCChamber* chamber = new CSCChamber( plane, chamberId, aSpecs );
-    theGeometry->addChamber( chamber ); 
-
-    std::cout << myName << ": Create chamber E" << jend << " S" << jstat 
- 	             << " R" << jring << " C" << jch 
-                     << " z=" << gtran[2]
-		     << " t/2=" << fpar[2] << " (DDD) or " << hChamberThickness 
-		     << " (specs) adr=" << chamber  << std::endl;
-
-    // Create the component layers of this chamber   
-    // We're taking the z as the z of the wire plane within the layer (middle of gas gap)
-
-    // Specify global z of layer by offsetting from centre of chamber: since layer 1 
-    // is nearest to IP in stations 1/2 but layer 6 is nearest in stations 3/4, 
-    // we need to adjust sign of offset appropriately...
-    int localZwrtGlobalZ = +1;
-    if ( (jend==1 && jstat<3 ) || ( jend==2 && jstat>2 ) ) localZwrtGlobalZ = -1;
-    int globalZ = +1;
-    if ( jend == 2 ) globalZ = -1;
-//     int localZwrtGlobalZ = +1;
-//     if ( (jend==1 && jstat<3 ) || ( jend==2 && jstat>2 ) ) localZwrtGlobalZ = -1;
-
-
-    std::cout << myName << ": layerSeparation=" << layerSeparation
-                     << ", zAF-zAverageAGV="  << zAverageAGVtoAF
-                     << ", localZwrtGlobalZ=" << localZwrtGlobalZ
-                     << ", gtran[2]=" << gtran[2]  << std::endl;
-
-    for ( short j = 1; j <= 6; ++j ) {
-
-      CSCDetId layerId = CSCDetId( jend, jstat, jring, jch, j );
-
-      // extra-careful check that we haven't already built this layer
-      const CSCLayer* cLayer = dynamic_cast<const CSCLayer*> (theGeometry->idToDet( layerId ) );
-
-      if ( cLayer == 0 ) {
-
-	// build the layer - need the chamber's specs and an appropriate layer-geometry
-         const CSCChamberSpecs* aSpecs = chamber->specs();
-         const CSCLayerGeometry* geom = 
-                    (j%2 != 0) ? aSpecs->oddLayerGeometry( jend ) : 
-                                 aSpecs->evenLayerGeometry( jend );
-
-        // Build appropriate BoundPlane, based on parent chamber, with gas gap as thickness
-
-	// centre of chamber is at global z = gtran[2]
-        float zlayer = gtran[2] - globalZ*zAverageAGVtoAF + localZwrtGlobalZ*(3.5-j)*layerSeparation;
-
-        Surface::RotationType chamberRotation = chamber->surface().rotation();
-        Surface::PositionType layerPosition( gtran[0], gtran[1], zlayer );
-	std::array<const float, 4> const & dims = geom->parameters(); // returns hb, ht, d, a
-        // dims[2] = layerThickness/2.; // half-thickness required and note it is 3rd value in vector
-        TrapezoidalPlaneBounds* bounds = new TrapezoidalPlaneBounds( dims[0], dims[1], dims[3], layerThickness/2. );
-        Plane::PlanePointer plane = Plane::build(layerPosition, chamberRotation, bounds);
-
-        CSCLayer* layer = new CSCLayer( plane, layerId, chamber, geom );
-
-        std::cout << myName << ": Create layer E" << jend << " S" << jstat 
-	            << " R" << jring << " C" << jch << " L" << j
-                    << " z=" << zlayer
-			 << " t=" << layerThickness << " or " << layer->surface().bounds().thickness()
-		    << " adr=" << layer << " layerGeom adr=" << geom  << std::endl;
-
-        chamber->addComponent(j, layer); 
-        theGeometry->addLayer( layer );
-      }
-      else {
-	std::cout << ": ERROR, layer " << j <<
-            " for chamber = " << ( chamber->id() ) <<
-            " already exists: layer address=" << cLayer <<
-            " chamber address=" << chamber << "\n" << std::endl;
-      }
-
-    } // layer construction within chamber
-  } // chamber construction
-}
diff --git a/Geometry/GEMGeometry/interface/ME0Chamber.h~ b/Geometry/GEMGeometry/interface/ME0Chamber.h~
deleted file mode 100644
index 9c5dea0..0000000
--- a/Geometry/GEMGeometry/interface/ME0Chamber.h~
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef GEMGeometry_GEMChamber_h
-#define GEMGeometry_GEMChamber_h
-
-/** \class GEMChamber
- *
- *  Model of a GEM chamber.
- *   
- *  A chamber is a GeomDet.
- *  The chamber is composed by 6,8 or 10 eta partitions (GeomDetUnit).
- *
- *  \author S. Dildick
- */
-
-#include "Geometry/CommonDetUnit/interface/GeomDet.h"
-#include "DataFormats/MuonDetId/interface/GEMDetId.h"
-
-class GEMEtaPartition;
-
-class GEMChamber : public GeomDet {
-public:
-  /// Constructor
-  GEMChamber(GEMDetId id, const ReferenceCountingPointer<BoundPlane>& plane);
-
-  /// Destructor
-  virtual ~GEMChamber();
-
-  /// Return the GEMDetId of this chamber
-  GEMDetId id() const;
-
-  // Which subdetector
-  virtual SubDetector subDetector() const {return GeomDetEnumerators::GEM;}
-
-  /// equal if the id is the same
-  bool operator==(const GEMChamber& ch) const;
-
-  /// Add EtaPartition to the chamber which takes ownership
-  void add(GEMEtaPartition* roll);
-
-  /// Return the rolls in the chamber
-  virtual std::vector<const GeomDet*> components() const;
-
-  /// Return the sub-component (roll) with a given id in this chamber
-  virtual const GeomDet* component(DetId id) const;
-
-  /// Return the eta partition corresponding to the given id 
-  const GEMEtaPartition* etaPartition(GEMDetId id) const;
-
-  const GEMEtaPartition* etaPartition(int isl) const;
-  
-  /// Return the eta partitions
-  const std::vector<const GEMEtaPartition*>& etaPartitions() const;
-
-  /// Retunr numbers of eta partitions
-  int nEtaPartitions() const;
-
-private:
-
-  GEMDetId detId_;
-
-  // vector of eta partitions for a chamber
-  std::vector<const GEMEtaPartition*> etaPartitions_;
-
-};
-#endif
diff --git a/Geometry/GEMGeometry/interface/ME0Geometry.h~ b/Geometry/GEMGeometry/interface/ME0Geometry.h~
deleted file mode 100644
index 054e251..0000000
--- a/Geometry/GEMGeometry/interface/ME0Geometry.h~
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef ME0Geometry_ME0Geometry_h
-#define ME0Geometry_ME0Geometry_h
-
-/** \class ME0Geometry
- *
- *  The model of the geometry of ME0.
- *
- *  \author M. Maggi - INFN Bari
- */
-
-#include "DataFormats/DetId/interface/DetId.h"
-#include "Geometry/CommonDetUnit/interface/TrackingGeometry.h"
-#include "Geometry/GEMGeometry/interface/ME0EtaPartition.h"
-#include <vector>
-#include <map>
-
-class GeomDetType;
-class GeomDetUnit;
-
-class ME0Geometry : public TrackingGeometry {
-
- public:
-  /// Default constructor
-  ME0Geometry();
-
-  /// Destructor
-  virtual ~ME0Geometry();
-
-  // Return a vector of all det types
-  virtual const DetTypeContainer&  detTypes() const;
-
-  // Return a vector of all GeomDetUnit
-  virtual const DetUnitContainer& detUnits() const;
-
-  // Return a vector of all GeomDet
-  virtual const DetContainer& dets() const;
-  
-  // Return a vector of all GeomDetUnit DetIds
-  virtual const DetIdContainer& detUnitIds() const;
-
-  // Return a vector of all GeomDet DetIds
-  virtual const DetIdContainer& detIds() const;
-
-  // Return the pointer to the GeomDetUnit corresponding to a given DetId
-  virtual const GeomDetUnit* idToDetUnit(DetId) const;
-
-  // Return the pointer to the GeomDet corresponding to a given DetId
-  virtual const GeomDet* idToDet(DetId) const;
-
-
-  //---- Extension of the interface
-
-  /// Return a vector of all ME0 eta partitions
-  const std::vector<ME0EtaPartition*>& etaPartitions() const;
-
-  /// Return a etaPartition given its id
-  const ME0EtaPartition* etaPartition(ME0DetId id) const;
-
-  /// Add a ME0 etaPartition  to the Geometry
-  void add(ME0EtaPartition* etaPartition);
-
- private:
-  DetUnitContainer theEtaPartitions;
-  DetContainer theDets;
-  DetTypeContainer theEtaPartitionTypes;
-  DetIdContainer theEtaPartitionIds;
-  DetIdContainer theDetIds;
-  
-  // Map for efficient lookup by DetId 
-  mapIdToDet theMap;
-
-  std::vector<ME0EtaPartition*> allEtaPartitions; // Are not owned by this class; are owned by their chamber.
-
-};
-
-#endif
diff --git a/Geometry/GEMGeometry/src/ME0Chamber.cc~ b/Geometry/GEMGeometry/src/ME0Chamber.cc~
deleted file mode 100644
index bf871e7..0000000
--- a/Geometry/GEMGeometry/src/ME0Chamber.cc~
+++ /dev/null
@@ -1,58 +0,0 @@
-/** 
- * Implementation of the Model for a ME0 Chamber
- *
- *  \author S.Dildick 
- */
-
-#include "Geometry/ME0Geometry/interface/ME0Chamber.h"
-#include "Geometry/ME0Geometry/interface/ME0EtaPartition.h"
-#include <iostream>
-
-ME0Chamber::ME0Chamber(ME0DetId id, const ReferenceCountingPointer<BoundPlane> & plane) :
-  GeomDet(plane), detId_(id)
-{
-  setDetId(id);
-}
-
-ME0Chamber::~ME0Chamber() {}
-
-ME0DetId ME0Chamber::id() const {
-  return detId_;
-}
-
-bool ME0Chamber::operator==(const ME0Chamber& ch) const {
-  return this->id()==ch.id();
-}
-
-void ME0Chamber::add(ME0EtaPartition* rl) {
-  etaPartitions_.push_back(rl);
-}
-
-std::vector<const GeomDet*> ME0Chamber::components() const {
-  return std::vector<const GeomDet*>(etaPartitions_.begin(), etaPartitions_.end());
-}
-
-const GeomDet* ME0Chamber::component(DetId id) const {
-  return etaPartition(ME0DetId(id.rawId()));
-}
-
-const std::vector<const ME0EtaPartition*>& ME0Chamber::etaPartitions() const {
-  return etaPartitions_;
-}
-
-int ME0Chamber::nEtaPartitions() const {
-  return etaPartitions_.size();
-}
-
-const ME0EtaPartition* ME0Chamber::etaPartition(ME0DetId id) const {
-  if (id.chamberId()!=detId_) return 0; // not in this eta partition!
-  return etaPartition(id.roll());
-}
-
-const ME0EtaPartition* ME0Chamber::etaPartition(int isl) const {
-  for (auto roll : etaPartitions_){
-    if (roll->id().roll()==isl) 
-      return roll;
-  }
-  return 0;
-}
diff --git a/Geometry/GEMGeometry/src/ME0Geometry.cc~ b/Geometry/GEMGeometry/src/ME0Geometry.cc~
deleted file mode 100644
index bba6be7..0000000
--- a/Geometry/GEMGeometry/src/ME0Geometry.cc~
+++ /dev/null
@@ -1,78 +0,0 @@
-/** Implementation of the Model for ME0 Geometry
- *
- *  \author M. Maggi - INFN Bari
- */
-
-#include <Geometry/GEMGeometry/interface/ME0Geometry.h>
-#include <Geometry/CommonDetUnit/interface/GeomDetUnit.h>
-
-ME0Geometry::ME0Geometry(){}
-
-
-ME0Geometry::~ME0Geometry(){}  
-
- 
-const ME0Geometry::DetTypeContainer&  ME0Geometry::detTypes() const{
-  return theEtaPartitionTypes;
-}
-
-
-const ME0Geometry::DetUnitContainer& ME0Geometry::detUnits() const{
-  return theEtaPartitions;
-}
-
-
-const ME0Geometry::DetContainer& ME0Geometry::dets() const{
-  return theDets;
-}
-
-  
-const ME0Geometry::DetIdContainer& ME0Geometry::detUnitIds() const{
-  return theEtaPartitionIds;
-}
-
-
-const ME0Geometry::DetIdContainer& ME0Geometry::detIds() const{
-  return theDetIds;
-}
-
-
-const GeomDetUnit* ME0Geometry::idToDetUnit(DetId id) const{
-  return dynamic_cast<const GeomDetUnit*>(idToDet(id));
-}
-
-const GeomDet* ME0Geometry::idToDet(DetId id) const{
-  mapIdToDet::const_iterator i = theMap.find(id);
-  return (i != theMap.end()) ?
-    i->second : 0 ;
-}
-
-/*
-const std::vector<ME0Chamber*>& ME0Geometry::chambers() const {
-  return allChambers;
-}
-*/
-
-
-const std::vector<ME0EtaPartition*>& ME0Geometry::etaPartitions() const{
-  return allEtaPartitions;
-}
-
-const ME0EtaPartition* ME0Geometry::etaPartition(ME0DetId id) const{
-  return dynamic_cast<const ME0EtaPartition*>(idToDetUnit(id));
-}
-
-
-void
-ME0Geometry::add(ME0EtaPartition* etaPartition){
-  theDets.push_back(etaPartition);
-  allEtaPartitions.push_back(etaPartition);
-  theEtaPartitions.push_back(etaPartition);
-  theEtaPartitionIds.push_back(etaPartition->geographicalId());
-  theDetIds.push_back(etaPartition->geographicalId());
-  GeomDetType* _t = const_cast<GeomDetType*>(&etaPartition->type());
-  theEtaPartitionTypes.push_back(_t);
-  theMap.insert(std::pair<DetId,GeomDetUnit*>
-		(etaPartition->geographicalId(),etaPartition));
-}
-
diff --git a/Geometry/GEMGeometryBuilder/src/GEMGeometryBuilderFromDDD.cc~ b/Geometry/GEMGeometryBuilder/src/GEMGeometryBuilderFromDDD.cc~
deleted file mode 100644
index 5dcabc1..0000000
--- a/Geometry/GEMGeometryBuilder/src/GEMGeometryBuilderFromDDD.cc~
+++ /dev/null
@@ -1,257 +0,0 @@
-/** Implementation of the GEM Geometry Builder from DDD
- *
- *  \author Port of: MuDDDGEMBuilder (ORCA)
- *  \author M. Maggi - INFN Bari
- */
-#include "Geometry/GEMGeometryBuilder/src/GEMGeometryBuilderFromDDD.h"
-#include "Geometry/GEMGeometry/interface/GEMGeometry.h"
-#include "Geometry/GEMGeometry/interface/GEMEtaPartitionSpecs.h"
-
-#include <DetectorDescription/Core/interface/DDFilter.h>
-#include <DetectorDescription/Core/interface/DDFilteredView.h>
-#include <DetectorDescription/Core/interface/DDSolid.h>
-
-#include "Geometry/MuonNumbering/interface/MuonDDDNumbering.h"
-#include "Geometry/MuonNumbering/interface/MuonBaseNumber.h"
-#include "Geometry/MuonNumbering/interface/GEMNumberingScheme.h"
-
-#include "DataFormats/GeometrySurface/interface/RectangularPlaneBounds.h"
-#include "DataFormats/GeometrySurface/interface/TrapezoidalPlaneBounds.h"
-
-#include "DataFormats/GeometryVector/interface/Basic3DVector.h"
-
-#include "CLHEP/Units/GlobalSystemOfUnits.h"
-
-#include <iostream>
-#include <algorithm>
-#include <boost/lexical_cast.hpp>
-
-GEMGeometryBuilderFromDDD::GEMGeometryBuilderFromDDD()
-{ }
-
-GEMGeometryBuilderFromDDD::~GEMGeometryBuilderFromDDD() 
-{ }
-
-GEMGeometry* GEMGeometryBuilderFromDDD::build(const DDCompactView* cview, const MuonDDDConstants& muonConstants)
-{
-  std::string attribute = "ReadOutName"; // could come from .orcarc
-  std::string value     = "MuonGEMHits";    // could come from .orcarc
-  DDValue val(attribute, value, 0.0);
-
-  // Asking only for the MuonGEM's
-  DDSpecificsFilter filter;
-  filter.setCriteria(val, // name & value of a variable 
-		     DDSpecificsFilter::matches,
-		     DDSpecificsFilter::AND, 
-		     true, // compare strings otherwise doubles
-		     true // use merged-specifics or simple-specifics
-		     );
-  DDFilteredView fview(*cview);
-  fview.addFilter(filter);
-
-  return this->buildGeometry(fview, muonConstants);
-}
-
-GEMGeometry* GEMGeometryBuilderFromDDD::buildGeometry(DDFilteredView& fview, const MuonDDDConstants& muonConstants)
-{
-  std::cout << "Building the geometry service" << std::endl;
-  LogDebug("GEMGeometryBuilderFromDDD") <<"Building the geometry service";
-  GEMGeometry* geometry = new GEMGeometry();
-
-  LogDebug("GEMGeometryBuilderFromDDD") << "About to run through the GEM structure\n" 
-					<<" First logical part "
-					<<fview.logicalPart().name().name();
-  bool doSubDets = fview.firstChild();
-  LogDebug("GEMGeometryBuilderFromDDD") << "doSubDets = " << doSubDets;
-
-  LogDebug("GEMGeometryBuilderFromDDD") <<"start the loop"; 
-  int nChambers(0);
-  int maxStation(1);
-  while (doSubDets)
-  {
-    // Get the Base Muon Number
-    MuonDDDNumbering mdddnum(muonConstants);
-    LogDebug("GEMGeometryBuilderFromDDD") <<"Getting the Muon base Number";
-    MuonBaseNumber mbn = mdddnum.geoHistoryToBaseNumber(fview.geoHistory());
-
-    LogDebug("GEMGeometryBuilderFromDDD") <<"Start the GEM Numbering Schema";
-    GEMNumberingScheme gemnum(muonConstants);
-
-    GEMDetId rollDetId(gemnum.baseNumberToUnitNumber(mbn));
-    LogDebug("GEMGeometryBuilderFromDDD") << "GEM eta partition rawId: " << rollDetId.rawId() << ", detId: " << rollDetId;
-
-    // chamber id for this partition. everything is the same; but partition number is 0.
-    GEMDetId chamberId(rollDetId.chamberId());
-    LogDebug("GEMGeometryBuilderFromDDD") << "GEM chamber rawId: " << chamberId.rawId() << ", detId: " << chamberId;
-    const int stationId(rollDetId.station());
-    if (stationId > maxStation) maxStation = stationId;
-    
-    if (rollDetId.roll()==1) ++nChambers;
-
-    DDValue numbOfStrips("nStrips");
-    DDValue numbOfPads("nPads");
-
-    std::vector<const DDsvalues_type* > specs(fview.specifics());
-    std::vector<const DDsvalues_type* >::iterator is = specs.begin();
-    double nStrips = 0., nPads = 0.;
-    for (;is != specs.end(); is++)
-    {
-      if (DDfetch( *is, numbOfStrips)) nStrips = numbOfStrips.doubles()[0];
-      if (DDfetch( *is, numbOfPads))   nPads = numbOfPads.doubles()[0];
-    }
-    LogDebug("GEMGeometryBuilderFromDDD") 
-      << ((nStrips == 0. ) ? ("No nStrips found!!") : ("Number of strips: " + boost::lexical_cast<std::string>(nStrips))); 
-    LogDebug("GEMGeometryBuilderFromDDD") 
-      << ((nPads == 0. ) ? ("No nPads found!!") : ("Number of pads: " + boost::lexical_cast<std::string>(nPads)));
-
-    std::vector<double> dpar=fview.logicalPart().solid().parameters();
-    std::string name = fview.logicalPart().name().name();
-    DDTranslation tran = fview.translation();
-   //removed .Inverse after comparing to DT...
-    DDRotationMatrix rota = fview.rotation();//.Inverse();
-    Surface::PositionType pos(tran.x()/cm, tran.y()/cm, tran.z()/cm);
-    // CLHEP way
-    // Surface::RotationType rot(rota.xx(),rota.xy(),rota.xz(),
-    //           	      rota.yx(),rota.yy(),rota.yz(),
-    // 			      rota.zx(),rota.zy(),rota.zz());
-
-    //ROOT::Math way
-    DD3Vector x, y, z;
-    rota.GetComponents(x,y,z);
-    // doesn't this just re-inverse???
-    Surface::RotationType rot(float(x.X()), float(x.Y()), float(x.Z()),
-			      float(y.X()), float(y.Y()), float(y.Z()),
-			      float(z.X()), float(z.Y()), float(z.Z())); 
-    
-    float be = dpar[4]/cm; // half bottom edge
-    float te = dpar[8]/cm; // half top edge
-    float ap = dpar[0]/cm; // half apothem
-    float ti = 0.4/cm;     // half thickness
-
-    //  TrapezoidalPlaneBounds* 
-    Bounds* bounds = new TrapezoidalPlaneBounds(be, te, ap, ti);
-
-    std::vector<float> pars;
-    pars.push_back(be); 
-    pars.push_back(te); 
-    pars.push_back(ap); 
-    pars.push_back(nStrips);
-    pars.push_back(nPads);
-
-    LogDebug("GEMGeometryBuilderFromDDD") 
-      << "GEM " << name << " par " << be << " " << te << " " << ap << " " << dpar[0];
-    
-    GEMEtaPartitionSpecs* e_p_specs = new GEMEtaPartitionSpecs(GeomDetEnumerators::GEM, name, pars);
-
-      //Change of axes for the forward
-    Basic3DVector<float> newX(1.,0.,0.);
-    Basic3DVector<float> newY(0.,0.,1.);
-    //      if (tran.z() > 0. )
-    newY *= -1;
-    Basic3DVector<float> newZ(0.,1.,0.);
-    rot.rotateAxes (newX, newY, newZ);
-    
-    BoundPlane* bp = new BoundPlane(pos, rot, bounds);
-    ReferenceCountingPointer<BoundPlane> surf(bp);
-    GEMEtaPartition* gep = new GEMEtaPartition(rollDetId, surf, e_p_specs);
-
-    // Add the eta partition to the geometry
-    geometry->add(gep);
-    // go to next layer
-    doSubDets = fview.nextSibling(); 
-  }
-  
-  auto& partitions(geometry->etaPartitions());
-  // build the chambers and add them to the geometry
-  std::vector<GEMDetId> vDetId;
-  vDetId.clear();
-  int oldRollNumber = 1;
-  for (unsigned i=1; i<=partitions.size(); ++i){
-    GEMDetId detId(partitions.at(i-1)->id());
-    const int rollNumber(detId.roll());
-    // new batch of eta partitions --> new chamber
-    if (rollNumber < oldRollNumber || i == partitions.size()) {
-      // don't forget the last partition for the last chamber
-      if (i == partitions.size()) vDetId.push_back(detId);
-
-      GEMDetId fId(vDetId.front());
-      GEMDetId chamberId(fId.chamberId());
-      // compute the overall boundplane using the first eta partition
-      const GEMEtaPartition* p(geometry->etaPartition(fId));
-      const BoundPlane& bps = p->surface();
-      BoundPlane* bp = const_cast<BoundPlane*>(&bps);
-      ReferenceCountingPointer<BoundPlane> surf(bp);
-      
-      GEMChamber* ch = new GEMChamber(chamberId, surf); 
-      LogDebug("GEMGeometryBuilderFromDDD")  << "Creating chamber " << chamberId << " with " << vDetId.size() << " eta partitions" << std::endl;
-      
-      for(auto id : vDetId){
-	LogDebug("GEMGeometryBuilderFromDDD") << "Adding eta partition " << id << " to GEM chamber" << std::endl;
-	ch->add(const_cast<GEMEtaPartition*>(geometry->etaPartition(id)));
-      }
-
-      LogDebug("GEMGeometryBuilderFromDDD") << "Adding the chamber to the geometry" << std::endl;
-      geometry->add(ch);
-      vDetId.clear();
-    }
-    vDetId.push_back(detId);
-    oldRollNumber = rollNumber;
-  }
-  
-  auto& chambers(geometry->chambers());
-  // construct super chambers
-  for (unsigned i=0; i<chambers.size(); ++i){
-    const BoundPlane& bps = chambers.at(i)->surface();
-    BoundPlane* bp = const_cast<BoundPlane*>(&bps);
-    ReferenceCountingPointer<BoundPlane> surf(bp);
-    GEMDetId detIdL1(chambers.at(i)->id());
-    if (detIdL1.layer()==2) continue;
-    GEMDetId detIdL2(detIdL1.region(),detIdL1.ring(),detIdL1.station(),2,detIdL1.chamber(),0);
-    auto ch2 = geometry->chamber(detIdL2);
-
-    LogDebug("GEMGeometryBuilderFromDDD") << "First chamber for super chamber: " << detIdL1 << std::endl;
-    LogDebug("GEMGeometryBuilderFromDDD") << "Second chamber for super chamber: " << detIdL2 << std::endl;
-
-    LogDebug("GEMGeometryBuilderFromDDD") << "Creating new GEM super chamber out of chambers." << std::endl;
-    GEMSuperChamber* sch = new GEMSuperChamber(detIdL1, surf); 
-    sch->add(const_cast<GEMChamber*>(chambers.at(i)));
-    sch->add(const_cast<GEMChamber*>(ch2));
-
-    LogDebug("GEMGeometryBuilderFromDDD") << "Adding the super chamber to the geometry." << std::endl;
-    geometry->add(sch);
-  }
-
-  auto& superChambers(geometry->superChambers());
-  // construct the regions, stations and rings. 
-  for (int re = -1; re <= 1; re = re+2) {
-    GEMRegion* region = new GEMRegion(re); 
-    for (int st=1; st<=maxStation; ++st) {
-      GEMStation* station = new GEMStation(re, st);
-      std::string sign( re==-1 ? "-" : "");
-      std::string name("GE" + sign + std::to_string(st) + "/1");
-      // Closest (furthest) super chambers in GE2/1 are called GE2/1s (GE2/1l)
-      if (st==2) name = "GE" + sign + std::to_string(st) + "/1s";
-      if (st==3) name = "GE" + sign + std::to_string(st-1) + "/1l";
-      station->setName(name); 
-      for (int ri=1; ri<=1; ++ri) {
-	GEMRing* ring = new GEMRing(re, st, ri); 
-	for (unsigned sch=0; sch<superChambers.size(); ++sch){
-	  const GEMDetId detId(superChambers.at(sch)->id());
-	  if (detId.region() != re || detId.station() != st || detId.ring() != ri) continue;
-	  ring->add(superChambers.at(sch));
-	  LogDebug("GEMGeometryBuilderFromDDD") << "Adding super chamber " << detId << " to ring: " 
-						<< "re " << re << " st " << st << " ri " << ri << std::endl;
- 	}
-	LogDebug("GEMGeometryBuilderFromDDD") << "Adding ring " <<  ri << " to station " << "re " << re << " st " << st << std::endl;
-	station->add(ring);
-	geometry->add(ring);
-      }
-      LogDebug("GEMGeometryBuilderFromDDD") << "Adding station " << st << " to region " << re << std::endl;
-      region->add(station);
-      geometry->add(station);
-    }
-    LogDebug("GEMGeometryBuilderFromDDD") << "Adding region " << re << " to the geometry " << std::endl;
-    geometry->add(region);
-  }
-  return geometry;
-}
diff --git a/Geometry/GEMGeometryBuilder/src/ME0GeometryBuilderFromDDD.cc~ b/Geometry/GEMGeometryBuilder/src/ME0GeometryBuilderFromDDD.cc~
deleted file mode 100644
index 40c5ad8..0000000
--- a/Geometry/GEMGeometryBuilder/src/ME0GeometryBuilderFromDDD.cc~
+++ /dev/null
@@ -1,236 +0,0 @@
-/** Implementation of the ME0 Geometry Builder from DDD
- *
- *  \author Port of: MuDDDME0Builder (ORCA)
- *  \author M. Maggi - INFN Bari
- */
-#include "Geometry/GEMGeometryBuilder/src/ME0GeometryBuilderFromDDD.h"
-#include "Geometry/GEMGeometry/interface/ME0Geometry.h"
-#include "Geometry/GEMGeometry/interface/ME0EtaPartitionSpecs.h"
-
-#include <DetectorDescription/Core/interface/DDFilter.h>
-#include <DetectorDescription/Core/interface/DDFilteredView.h>
-#include <DetectorDescription/Core/interface/DDSolid.h>
-
-#include "Geometry/MuonNumbering/interface/MuonDDDNumbering.h"
-#include "Geometry/MuonNumbering/interface/MuonBaseNumber.h"
-#include "Geometry/MuonNumbering/interface/ME0NumberingScheme.h"
-
-#include "DataFormats/GeometrySurface/interface/RectangularPlaneBounds.h"
-#include "DataFormats/GeometrySurface/interface/TrapezoidalPlaneBounds.h"
-
-#include "DataFormats/GeometryVector/interface/Basic3DVector.h"
-
-#include "CLHEP/Units/GlobalSystemOfUnits.h"
-
-#include <iostream>
-#include <algorithm>
-#include <boost/lexical_cast.hpp>
-
-ME0GeometryBuilderFromDDD::ME0GeometryBuilderFromDDD()
-{ }
-
-ME0GeometryBuilderFromDDD::~ME0GeometryBuilderFromDDD() 
-{ }
-
-ME0Geometry* ME0GeometryBuilderFromDDD::build(const DDCompactView* cview, const MuonDDDConstants& muonConstants)
-{
-  std::string attribute = "ReadOutName"; // could come from .orcarc
-  std::string value     = "MuonME0Hits";    // could come from .orcarc
-  DDValue val(attribute, value, 0.0);
-
-  // Asking only for the MuonME0's
-  DDSpecificsFilter filter;
-  filter.setCriteria(val, // name & value of a variable 
-		     DDSpecificsFilter::matches,
-		     DDSpecificsFilter::AND, 
-		     true, // compare strings otherwise doubles
-		     true // use merged-specifics or simple-specifics
-		     );
-  DDFilteredView fview(*cview);
-  fview.addFilter(filter);
-
-  return this->buildGeometry(fview, muonConstants);
-}
-
-ME0Geometry* ME0GeometryBuilderFromDDD::buildGeometry(DDFilteredView& fview, const MuonDDDConstants& muonConstants)
-{
-  std::cout <<"Building the geometry service" << std::endl;
-  ME0Geometry* geometry = new ME0Geometry();
-
-  std::cout << "About to run through the ME0 structure\n" 
-					<<" First logical part "
-					<<fview.logicalPart().name().name() << std::endl;
-
-
-  bool doSubDets = fview.firstChild();
- 
-  std::cout << "doSubDets = " << doSubDets << std::endl;
-
-   std::cout <<"start the loop" << std::endl; 
-  while (doSubDets)
-  {
-    // Get the Base Muon Number
-    MuonDDDNumbering mdddnum(muonConstants);
-    std::cout <<"Getting the Muon base Number" << std::endl;
-    MuonBaseNumber mbn = mdddnum.geoHistoryToBaseNumber(fview.geoHistory());
-
-    std::cout <<"Start the ME0 Numbering Schema" << std::endl;
-    ME0NumberingScheme me0num(muonConstants);
-
-    ME0DetId rollDetId(me0num.baseNumberToUnitNumber(mbn));
-    std::cout << "ME0 eta partition rawId: " << rollDetId.rawId() << ", detId: " << rollDetId << std::endl;
-
-    std::vector<double> dpar=fview.logicalPart().solid().parameters();
-    std::string name = fview.logicalPart().name().name();
-    DDTranslation tran = fview.translation();
-    DDRotationMatrix rota = fview.rotation();
-    Surface::PositionType pos(tran.x()/cm, tran.y()/cm, tran.z()/cm);
-    // CLHEP way
-    // Surface::RotationType rot(rota.xx(),rota.xy(),rota.xz(),
-    //           	      rota.yx(),rota.yy(),rota.yz(),
-    // 			      rota.zx(),rota.zy(),rota.zz());
-
-    //ROOT::Math way
-    DD3Vector x, y, z;
-    rota.GetComponents(x,y,z);
-    // doesn't this just re-inverse???
-    Surface::RotationType rot(float(x.X()), float(x.Y()), float(x.Z()),
-			      float(y.X()), float(y.Y()), float(y.Z()),
-			      float(z.X()), float(z.Y()), float(z.Z())); 
-    
-    float be = dpar[4]/cm; // half bottom edge
-    float te = dpar[8]/cm; // half top edge
-    float ap = dpar[0]/cm; // half apothem
-    float ti = 0.4/cm;     // half thickness
-
-    //  TrapezoidalPlaneBounds* 
-    Bounds* bounds = new TrapezoidalPlaneBounds(be, te, ap, ti);
-
-    std::vector<float> pars;
-    pars.push_back(be); 
-    pars.push_back(te); 
-    pars.push_back(ap);
-    float nStrips = -999.;
-    float nPads = -999.;
-    pars.push_back(nStrips);
-    pars.push_back(nPads);
-
-    std::cout 
-      << "ME0 " << name << " par " << be << " " << te << " " << ap << " " << dpar[0] << std::endl;
-    
-    ME0EtaPartitionSpecs* e_p_specs = new ME0EtaPartitionSpecs(GeomDetEnumerators::ME0, name, pars);
-
-      //Change of axes for the forward
-    Basic3DVector<float> newX(1.,0.,0.);
-    Basic3DVector<float> newY(0.,0.,1.);
-    //      if (tran.z() > 0. )
-    newY *= -1;
-    Basic3DVector<float> newZ(0.,1.,0.);
-    rot.rotateAxes (newX, newY, newZ);
-    
-    BoundPlane* bp = new BoundPlane(pos, rot, bounds);
-    ReferenceCountingPointer<BoundPlane> surf(bp);
-    ME0EtaPartition* mep = new ME0EtaPartition(rollDetId, surf, e_p_specs);
-
-    // Add the eta partition to the geometry
-    geometry->add(mep);
-    // go to next layer
-    doSubDets = fview.nextSibling(); 
-  }
-  
-  /*
-  auto& partitions(geometry->etaPartitions());
-  // build the chambers and add them to the geometry
-  std::vector<ME0DetId> vDetId;
-  vDetId.clear();
-  int oldRollNumber = 1;
-  for (unsigned i=1; i<=partitions.size(); ++i){
-    ME0DetId detId(partitions.at(i-1)->id());
-    const int rollNumber(detId.roll());
-    // new batch of eta partitions --> new chamber
-    if (rollNumber < oldRollNumber || i == partitions.size()) {
-      // don't forget the last partition for the last chamber
-      if (i == partitions.size()) vDetId.push_back(detId);
-
-      ME0DetId fId(vDetId.front());
-      ME0DetId chamberId(fId.chamberId());
-      // compute the overall boundplane using the first eta partition
-      const ME0EtaPartition* p(geometry->etaPartition(fId));
-      const BoundPlane& bps = p->surface();
-      BoundPlane* bp = const_cast<BoundPlane*>(&bps);
-      ReferenceCountingPointer<BoundPlane> surf(bp);
-      
-      ME0Chamber* ch = new ME0Chamber(chamberId, surf); 
-      std::cout  << "Creating chamber " << chamberId << " with " << vDetId.size() << " eta partitions" << std::endl;
-      
-      for(auto id : vDetId){
-	std::cout << "Adding eta partition " << id << " to ME0 chamber" << std::endl;
-	ch->add(const_cast<ME0EtaPartition*>(geometry->etaPartition(id)));
-      }
-
-      std::cout << "Adding the chamber to the geometry" << std::endl;
-      geometry->add(ch);
-      vDetId.clear();
-    }
-    vDetId.push_back(detId);
-    oldRollNumber = rollNumber;
-  }
-  
-  auto& chambers(geometry->chambers());
-  // construct super chambers
-  for (unsigned i=0; i<chambers.size(); ++i){
-    const BoundPlane& bps = chambers.at(i)->surface();
-    BoundPlane* bp = const_cast<BoundPlane*>(&bps);
-    ReferenceCountingPointer<BoundPlane> surf(bp);
-    ME0DetId detIdL1(chambers.at(i)->id());
-    if (detIdL1.layer()==2) continue;
-    ME0DetId detIdL2(detIdL1.region(),detIdL1.ring(),detIdL1.station(),2,detIdL1.chamber(),0);
-    auto ch2 = geometry->chamber(detIdL2);
-
-    std::cout << "First chamber for super chamber: " << detIdL1 << std::endl;
-    std::cout << "Second chamber for super chamber: " << detIdL2 << std::endl;
-
-    std::cout << "Creating new ME0 super chamber out of chambers." << std::endl;
-    ME0SuperChamber* sch = new ME0SuperChamber(detIdL1, surf); 
-    sch->add(const_cast<ME0Chamber*>(chambers.at(i)));
-    sch->add(const_cast<ME0Chamber*>(ch2));
-
-    std::cout << "Adding the super chamber to the geometry." << std::endl;
-    geometry->add(sch);
-  }
-
-  auto& superChambers(geometry->superChambers());
-  // construct the regions, stations and rings. 
-  std::cout << "maxStation " << maxStation << std::endl;
-  for (int re = -1; re <= 1; re = re+2) {
-    ME0Region* region = new ME0Region(re); 
-    for (int st=1; st<=maxStation; ++st) {
-      ME0Station* station = new ME0Station(re, st); 
-      std::string name("ME+ std::to_string(re) + "/" + std::to_string(st));
-      // Closest (furthest) super chambers in GE2/1 are called GE2/1s (GE2/1l)
-      if (st==2) name = "GE" + std::to_string(re) + "/" + std::to_string(st) + "s";
-      if (st==3) name = "GE" + std::to_string(re) + "/" + std::to_string(st-1) + "l";
-      station->setName(name); 
-      for (int ri=1; ri<=1; ++ri) {
-	ME0Ring* ring = new ME0Ring(re, st, ri); 
-	for (unsigned sch=0; sch<superChambers.size(); ++sch){
-	  const ME0DetId detId(superChambers.at(sch)->id());
-	  if (detId.region() != re || detId.station() != st || detId.ring() != ri) continue;
-	  ring->add(superChambers.at(sch));
-	  std::cout << "Adding super chamber " << detId << " to ring: " 
-						<< "re " << re << " st " << st << " ri " << ri << std::endl;
- 	}
-	std::cout << "Adding ring " <<  ri << " to station " << "re " << re << " st " << st << std::endl;
-	station->add(ring);
-	geometry->add(ring);
-      }
-      std::cout << "Adding station " << st << " to region " << re << std::endl;
-      region->add(station);
-      geometry->add(station);
-    }
-    std::cout << "Adding region " << re << " to the geometry " << std::endl;
-    geometry->add(region);
-  }
-  */
-  return geometry;
-}
diff --git a/RecoLocalMuon/GEMRecHit/src/ME0SegAlgoMM.cc~ b/RecoLocalMuon/GEMRecHit/src/ME0SegAlgoMM.cc~
deleted file mode 100644
index 040c3e7..0000000
--- a/RecoLocalMuon/GEMRecHit/src/ME0SegAlgoMM.cc~
+++ /dev/null
@@ -1,575 +0,0 @@
-/**
- * \file ME0SegAlgoMM.cc
- *
- *  \authors: Marcello Maggi
- */
- 
-#include "ME0SegAlgoMM.h"
-#include "DataFormats/GeometryVector/interface/GlobalPoint.h"
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-#include "CommonTools/Statistics/interface/ChiSquaredProbability.h"
-
-#include <algorithm>
-#include <cmath>
-#include <iostream>
-#include <string>
-
-/* Constructor
- *
- */
-ME0SegAlgoMM::ME0SegAlgoMM(const edm::ParameterSet& ps) : ME0SegmentAlgorithm(ps), myName("ME0SegAlgoMM") {
-	 
-  debug                     = ps.getUntrackedParameter<bool>("ME0Debug");
-  minHitsPerSegment         = ps.getParameter<unsigned int>("minHitsPerSegment");
-  preClustering             = ps.getParameter<bool>("preClustering");
-  dXclusBoxMax              = ps.getParameter<double>("dXclusBoxMax");
-  dYclusBoxMax              = ps.getParameter<double>("dYclusBoxMax");
-  preClustering_useChaining = ps.getParameter<bool>("preClusteringUseChaining");
-  dPhiChainBoxMax           = ps.getParameter<double>("dPhiChainBoxMax");
-  dEtaChainBoxMax           = ps.getParameter<double>("dEtaChainBoxMax");
-  maxRecHitsInCluster       = ps.getParameter<int>("maxRecHitsInCluster");
-}
-
-/* Destructor
- *
- */
-ME0SegAlgoMM::~ME0SegAlgoMM() {
-}
-
-
-std::vector<ME0Segment> ME0SegAlgoMM::run(ME0Ensamble ensamble, const EnsambleHitContainer& rechits) {
-
-  theEnsamble = ensamble;
-  //ME0DetId enId();
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::run] build segments in chamber ";
-  
-  // pre-cluster rechits and loop over all sub clusters seperately
-  std::vector<ME0Segment>          segments_temp;
-  std::vector<ME0Segment>          segments;
-  ProtoSegments rechits_clusters; // this is a collection of groups of rechits
-  
-  if(preClustering) {
-    // run a pre-clusterer on the given rechits to split obviously separated segment seeds:
-    if(preClustering_useChaining){
-      // it uses X,Y,Z information; there are no configurable parameters used;
-      // the X, Y, Z "cuts" are just (much) wider than the LCT readout ones
-      // (which are actually not step functions); this new code could accomodate
-      // the clusterHits one below but we leave it for security and backward 
-      // comparison reasons 
-      rechits_clusters = this->chainHits( rechits );
-    }
-    else{
-      // it uses X,Y information + configurable parameters
-      rechits_clusters = this->clusterHits(rechits );
-    }
-    // loop over the found clusters:
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::run] Looping over found clusters ";
-    for(auto sub_rechits = rechits_clusters.begin(); sub_rechits !=  rechits_clusters.end(); ++sub_rechits ) {
-      // clear the buffer for the subset of segments:
-      LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::run] Clearing buffer ";
-      segments_temp.clear();
-      // build the subset of segments:
-      LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::run] Building subset ";
-      segments_temp = this->buildSegments( (*sub_rechits) );
-      // add the found subset of segments to the collection of all segments in this chamber:
-      LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::run] Adding found subset of segments ";
-      segments.insert( segments.end(), segments_temp.begin(), segments_temp.end() );
-    }
-  
-
-    return segments;
-  }
-  else {
-    segments = this->buildSegments(rechits);
-    return segments;
-  }
-}
-
-
-// ********************************************************************;
-ME0SegAlgoMM::ProtoSegments 
-ME0SegAlgoMM::clusterHits(const EnsambleHitContainer & rechits) {
-
-  ProtoSegments rechits_clusters; // this is a collection of groups of rechits
-  //   const float dXclus_box_cut       = 4.; // seems to work reasonably 070116
-  //   const float dYclus_box_cut       = 8.; // seems to work reasonably 070116
-
-  float dXclus_box = 0.0;
-  float dYclus_box = 0.0;
-
-  EnsambleHitContainer temp;
-  ProtoSegments seeds;
-
-  std::vector<float> running_meanX;
-  std::vector<float> running_meanY;
-
-  std::vector<float> seed_minX;
-  std::vector<float> seed_maxX;
-  std::vector<float> seed_minY;
-  std::vector<float> seed_maxY;
-
-   // split rechits into subvectors and return vector of vectors:
-  // Loop over rechits 
-  // Create one seed per hit
-  for(unsigned int i = 0; i < rechits.size(); ++i) {
-    temp.clear();
-    temp.push_back(rechits[i]);
-    seeds.push_back(temp);
-
-    // First added hit in seed defines the mean to which the next hit is compared
-    // for this seed.
-
-    running_meanX.push_back( rechits[i]->localPosition().x() );
-    running_meanY.push_back( rechits[i]->localPosition().y() );
-	
-    // set min/max X and Y for box containing the hits in the precluster:
-    seed_minX.push_back( rechits[i]->localPosition().x() );
-    seed_maxX.push_back( rechits[i]->localPosition().x() );
-    seed_minY.push_back( rechits[i]->localPosition().y() );
-    seed_maxY.push_back( rechits[i]->localPosition().y() );
-  }
-    
-  // merge clusters that are too close
-  // measure distance between final "running mean"
-  for(size_t NNN = 0; NNN < seeds.size(); ++NNN) {
-    for(size_t MMM = NNN+1; MMM < seeds.size(); ++MMM) {
-      if(running_meanX[MMM] == 999999. || running_meanX[NNN] == 999999. ) {
-	LogDebug("ME0Segment|ME0") << "ME0SegAlgoMM::clusterHits: Warning: Skipping used seeds, this should happen - inform developers!";
-	//	std::cout<<"We should never see this line now!!!"<<std::endl;
-	continue; //skip seeds that have been used 
-      }
-	  
-      // calculate cut criteria for simple running mean distance cut:
-      //dXclus = fabs(running_meanX[NNN] - running_meanX[MMM]);
-      //dYclus = fabs(running_meanY[NNN] - running_meanY[MMM]);
-      // calculate minmal distance between precluster boxes containing the hits:
-      if ( running_meanX[NNN] > running_meanX[MMM] ) dXclus_box = seed_minX[NNN] - seed_maxX[MMM];
-      else                                           dXclus_box = seed_minX[MMM] - seed_maxX[NNN];
-      if ( running_meanY[NNN] > running_meanY[MMM] ) dYclus_box = seed_minY[NNN] - seed_maxY[MMM];
-      else                                           dYclus_box = seed_minY[MMM] - seed_maxY[NNN];
-	  
-	  
-      if( dXclus_box < dXclusBoxMax && dYclus_box < dYclusBoxMax ) {
-	// merge clusters!
-	// merge by adding seed NNN to seed MMM and erasing seed NNN
-	    
-	// calculate running mean for the merged seed:
-	running_meanX[MMM] = (running_meanX[NNN]*seeds[NNN].size() + running_meanX[MMM]*seeds[MMM].size()) / (seeds[NNN].size()+seeds[MMM].size());
-	running_meanY[MMM] = (running_meanY[NNN]*seeds[NNN].size() + running_meanY[MMM]*seeds[MMM].size()) / (seeds[NNN].size()+seeds[MMM].size());
-	    
-	// update min/max X and Y for box containing the hits in the merged cluster:
-	if ( seed_minX[NNN] <= seed_minX[MMM] ) seed_minX[MMM] = seed_minX[NNN];
-	if ( seed_maxX[NNN] >  seed_maxX[MMM] ) seed_maxX[MMM] = seed_maxX[NNN];
-	if ( seed_minY[NNN] <= seed_minY[MMM] ) seed_minY[MMM] = seed_minY[NNN];
-	if ( seed_maxY[NNN] >  seed_maxY[MMM] ) seed_maxY[MMM] = seed_maxY[NNN];
-	    
-	// add seed NNN to MMM (lower to larger number)
-	seeds[MMM].insert(seeds[MMM].end(),seeds[NNN].begin(),seeds[NNN].end());
-	    
-	// mark seed NNN as used (at the moment just set running mean to 999999.)
-	running_meanX[NNN] = 999999.;
-	running_meanY[NNN] = 999999.;
-	// we have merged a seed (NNN) to the highter seed (MMM) - need to contimue to 
-	// next seed (NNN+1)
-	break;
-      }
-    }
-  }
-
-  // hand over the final seeds to the output
-  // would be more elegant if we could do the above step with 
-  // erasing the merged ones, rather than the 
-  for(size_t NNN = 0; NNN < seeds.size(); ++NNN) {
-    if(running_meanX[NNN] == 999999.) continue; //skip seeds that have been marked as used up in merging
-    rechits_clusters.push_back(seeds[NNN]);
-  }
-
-  return rechits_clusters; 
-}
-
-
-ME0SegAlgoMM::ProtoSegments 
-ME0SegAlgoMM::chainHits(const EnsambleHitContainer & rechits) {
-
-  ProtoSegments rechits_chains; 
-  EnsambleHitContainer temp;
-  ProtoSegments seeds;
-
-  std::vector <bool> usedCluster;
-
-  // split rechits into subvectors and return vector of vectors:
-  // Loop over rechits
-  // Create one seed per hit
-  for(unsigned int i = 0; i < rechits.size(); ++i) {
-    temp.clear();
-    temp.push_back(rechits[i]);
-    seeds.push_back(temp);
-    usedCluster.push_back(false);
-  }
-
-  // merge chains that are too close ("touch" each other)
-  for(size_t NNN = 0; NNN < seeds.size(); ++NNN) {
-    for(size_t MMM = NNN+1; MMM < seeds.size(); ++MMM) {
-      if(usedCluster[MMM] || usedCluster[NNN]){
-        continue;
-      }
-      // all is in the way we define "good";
-      // try not to "cluster" the hits but to "chain" them;
-      // it does the clustering but also does a better job
-      // for inclined tracks (not clustering them together;
-      // crossed tracks would be still clustered together) 
-      // 22.12.09: In fact it is not much more different 
-      // than the "clustering", we just introduce another
-      // variable in the game - Z. And it makes sense 
-      // to re-introduce Y (or actually wire group mumber)
-      // in a similar way as for the strip number - see
-      // the code below.
-      bool goodToMerge  = isGoodToMerge(seeds[NNN], seeds[MMM]);
-      if(goodToMerge){
-        // merge chains!
-        // merge by adding seed NNN to seed MMM and erasing seed NNN
-
-        // add seed NNN to MMM (lower to larger number)
-        seeds[MMM].insert(seeds[MMM].end(),seeds[NNN].begin(),seeds[NNN].end());
-
-        // mark seed NNN as used
-        usedCluster[NNN] = true;
-        // we have merged a seed (NNN) to the highter seed (MMM) - need to contimue to
-        // next seed (NNN+1)
-        break;
-      }
-
-    }
-  }
-
-  // hand over the final seeds to the output
-  // would be more elegant if we could do the above step with
-  // erasing the merged ones, rather than the
-
-  for(size_t NNN = 0; NNN < seeds.size(); ++NNN) {
-    if(usedCluster[NNN]) continue; //skip seeds that have been marked as used up in merging
-    rechits_chains.push_back(seeds[NNN]);
-  }
-
-  //***************************************************************
-
-      return rechits_chains;
-}
-
-bool ME0SegAlgoMM::isGoodToMerge(EnsambleHitContainer & newChain, EnsambleHitContainer & oldChain) {
-   for(size_t iRH_new = 0;iRH_new<newChain.size();++iRH_new){
-    int layer_new = newChain[iRH_new]->me0Id().layer();     
-    float phi_new = theEnsamble.first->toGlobal(newChain[iRH_new]->localPosition()).phi();
-    float eta_new = theEnsamble.first->toGlobal(newChain[iRH_new]->localPosition()).eta();
-    for(size_t iRH_old = 0;iRH_old<oldChain.size();++iRH_old){      
-      int layer_old = oldChain[iRH_old]->me0Id().layer();
-      float phi_old = theEnsamble.first->toGlobal(oldChain[iRH_old]->localPosition()).phi();
-      float eta_old = theEnsamble.first->toGlobal(oldChain[iRH_old]->localPosition()).eta();
-      // to be chained, two hits need to be in neighbouring layers...
-      // or better allow few missing layers (upto 3 to avoid inefficiencies);
-      // however we'll not make an angle correction because it
-      // worsen the situation in some of the "regular" cases 
-      // (not making the correction means that the conditions for
-      // forming a cluster are different if we have missing layers -
-      // this could affect events at the boundaries ) 
-      //to be chained, two hits need also to be "close" in phi and eta
-      bool layerRequirementOK = abs(layer_new-layer_old)<5;
-      bool phiRequirementOK = fabs(phi_old-phi_new) < dPhiChainBoxMax;
-      bool etaRequirementOK = fabs(eta_old-eta_new) < dEtaChainBoxMax;
-      
-      if(layerRequirementOK && phiRequirementOK && etaRequirementOK){
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-
-
-
-
-std::vector<ME0Segment> ME0SegAlgoMM::buildSegments(const EnsambleHitContainer& rechits) {
-  std::vector<ME0Segment> me0segs;
-
-  proto_segment.clear();
-  // select hits from the ensemble and sort it 
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::buildSegments] Sorting hits ";
-  for (auto rh=rechits.begin(); rh!=rechits.end();rh++){
-    proto_segment.push_back(*rh);
-  }
-  if (proto_segment.size() < minHitsPerSegment){
-    return me0segs;
-  }
-  // The actual fit on all hit of the protosegments;
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::buildSegments] Fitting all hits ";
-  this->doSlopesAndChi2();
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::buildSegments] Filling direction ";
-  this->fillLocalDirection();
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::buildSegments] Getting errors ";
-  AlgebraicSymMatrix protoErrors = this->calculateError();
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::buildSegments] Flipping errors ";
-  this->flipErrors( protoErrors ); 
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::buildSegments] Making an ME0Segment ";
-  ME0Segment tmp(proto_segment,protoIntercept, protoDirection, protoErrors,protoChi2);
-  me0segs.push_back(tmp);
-  return me0segs;
-}
-
-//Method doSlopesAndChi2
-// fitSlopes() and  fillChiSquared() are always called one after the other 
-// In fact the code is duplicated in the two functions (as we need 2 loops) - 
-// it is much better to fix that at some point 
-void ME0SegAlgoMM::doSlopesAndChi2(){
-  this->fitSlopes();
-  this->fillChiSquared();
-}
-/* Method fitSlopes
- *
- * Perform a Least Square Fit on a segment as per SK algo
- *
- */
-void ME0SegAlgoMM::fitSlopes() {
-
-  CLHEP::HepMatrix M(4,4,0);
-  CLHEP::HepVector B(4,0);
-  // In absence of a geometrical construction of the ME0Ensamble take layer 1  
-  const ME0EtaPartition* ens = theEnsamble.first;
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Looping over proto segments ";
-  for (auto ih = proto_segment.begin(); ih != proto_segment.end(); ++ih) {
-    const ME0RecHit& hit = (**ih);
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] About to grab roll with id: " <<hit.me0Id();
-    const ME0EtaPartition* roll  = theEnsamble.second[hit.me0Id()];
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Making a global point ";
-    GlobalPoint gp         = roll->toGlobal(hit.localPosition());
-    // Locat w,r,t, to the first layer;
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Getting local position ";
-    LocalPoint  lp         = ens->toLocal(gp); 
-    // ptc: Local position of hit w.r.t. chamber
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Making local position ";
-    double u = lp.x();
-    double v = lp.y();
-    double z = lp.z();
-    // ptc: Covariance matrix of local errors 
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Making covariance ";
-    CLHEP::HepMatrix IC(2,2);
-    IC(1,1) = hit.localPositionError().xx();
-    IC(1,2) = hit.localPositionError().xy();
-    IC(2,2) = hit.localPositionError().yy();
-    IC(2,1) = IC(1,2); // since Cov is symmetric
-    // ptc: Invert covariance matrix (and trap if it fails!)
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Inverting covariance ";
-    int ierr = 0;
-    IC.invert(ierr); // inverts in place
-    if (ierr != 0) {
-      LogDebug("ME0Segment|ME0") << "ME0Segment::fitSlopes: failed to invert covariance matrix=\n" << IC;      
-      //       std::cout<< "ME0Segment::fitSlopes: failed to invert covariance matrix=\n" << IC << "\n"<<std::endl;
-    }
-    
-    LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Math incoming...";
-    M(1,1) += IC(1,1);
-    M(1,2) += IC(1,2);
-    M(1,3) += IC(1,1) * z;
-    M(1,4) += IC(1,2) * z;
-    B(1)   += u * IC(1,1) + v * IC(1,2);
-    
-    M(2,1) += IC(2,1);
-    M(2,2) += IC(2,2);
-    M(2,3) += IC(2,1) * z;
-    M(2,4) += IC(2,2) * z;
-    B(2)   += u * IC(2,1) + v * IC(2,2);
-    
-    M(3,1) += IC(1,1) * z;
-    M(3,2) += IC(1,2) * z;
-    M(3,3) += IC(1,1) * z * z;
-    M(3,4) += IC(1,2) * z * z;
-    B(3)   += ( u * IC(1,1) + v * IC(1,2) ) * z;
-    
-    M(4,1) += IC(2,1) * z;
-    M(4,2) += IC(2,2) * z;
-    M(4,3) += IC(2,1) * z * z;
-    M(4,4) += IC(2,2) * z * z;
-    B(4)   += ( u * IC(2,1) + v * IC(2,2) ) * z;
-  }
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Solve for p";
-  CLHEP::HepVector p = solve(M, B);
-  
-  // Update member variables 
-  // Note that origin has local z = 0
-  LogTrace("ME0SegAlgoMM|ME0") << "[ME0SegAlgoMM::fitSlopes] Update variables";
-  protoIntercept = LocalPoint(p(1), p(2), 0.);
-  protoSlope_u = p(3);
-  protoSlope_v = p(4);
-}
-/* Method fillChiSquared
- *
- * Determine Chi^2 for the proto wire segment
- *
- */
-void ME0SegAlgoMM::fillChiSquared() {
-  
-  double chsq = 0.; 
-  const ME0EtaPartition* ens = theEnsamble.first;
-  for (auto ih = proto_segment.begin(); ih != proto_segment.end(); ++ih) {
-    const ME0RecHit& hit = (**ih);
-    const ME0EtaPartition* roll  = theEnsamble.second[hit.me0Id()];
-    GlobalPoint gp         = roll->toGlobal(hit.localPosition());
-    // Locat w,r,t, to the first layer;
-    LocalPoint  lp         = ens->toLocal(gp); 
-    // ptc: Local position of hit w.r.t. chamber
-    double u = lp.x();
-    double v = lp.y();
-    double z = lp.z();
-    
-    double du = protoIntercept.x() + protoSlope_u * z - u;
-    double dv = protoIntercept.y() + protoSlope_v * z - v;
-    
-    CLHEP::HepMatrix IC(2,2);
-    IC(1,1) = hit.localPositionError().xx();
-    //    IC(1,1) = hit.localPositionError().xx();
-    IC(1,2) = hit.localPositionError().xy();
-    IC(2,2) = hit.localPositionError().yy();
-    IC(2,1) = IC(1,2);
-
-    
-    // Invert covariance matrix
-    int ierr = 0;
-    IC.invert(ierr);
-    if (ierr != 0) {
-      LogDebug("ME0Segment|ME0") << "ME0Segment::fillChiSquared: failed to invert covariance matrix=\n" << IC;
-      //       std::cout << "ME0Segment::fillChiSquared: failed to invert covariance matrix=\n" << IC << "\n";
-      
-    }
-    
-    chsq += du*du*IC(1,1) + 2.*du*dv*IC(1,2) + dv*dv*IC(2,2);
-  }
-
-  protoChi2 = chsq;
-  protoNDF = 2.*proto_segment.size() - 4;
-}
-/* fillLocalDirection
- *
- */
-void ME0SegAlgoMM::fillLocalDirection() {
-  // Always enforce direction of segment to point from IP outwards
-  // (Incorrect for particles not coming from IP, of course.)
-  
-  double dxdz = protoSlope_u;
-  double dydz = protoSlope_v;
-  double dz   = 1./sqrt(1. + dxdz*dxdz + dydz*dydz);
-  double dx   = dz*dxdz;
-  double dy   = dz*dydz;
-  LocalVector localDir(dx,dy,dz);
-  
-  // localDir may need sign flip to ensure it points outward from IP
-  // ptc: Examine its direction and origin in global z: to point outward
-  // the localDir should always have same sign as global z...
-  const ME0EtaPartition* ens = theEnsamble.first;
-
-  double globalZpos    = ( ens->toGlobal( protoIntercept ) ).z();
-  double globalZdir    = ( ens->toGlobal( localDir ) ).z();
-  double directionSign = globalZpos * globalZdir;
-  protoDirection       = (directionSign * localDir).unit();
-}
-
-/* weightMatrix
- *   
- */
-AlgebraicSymMatrix ME0SegAlgoMM::weightMatrix() {
-  
-  std::vector<const ME0RecHit*>::const_iterator it;
-  int nhits = proto_segment.size();
-  AlgebraicSymMatrix matrix(2*nhits, 0);
-  int row = 0;
-  
-  for (it = proto_segment.begin(); it != proto_segment.end(); ++it) {
-    
-    const ME0RecHit& hit = (**it);
-    ++row;
-    matrix(row, row)   = protoChiUCorrection*hit.localPositionError().xx();
-    matrix(row, row+1) = hit.localPositionError().xy();
-    ++row;
-    matrix(row, row-1) = hit.localPositionError().xy();
-    matrix(row, row)   = hit.localPositionError().yy();
-  }
-  int ierr;
-  matrix.invert(ierr);
-  return matrix;
-}
-
-
-/* derivativeMatrix
- *
- */
-CLHEP::HepMatrix ME0SegAlgoMM::derivativeMatrix(){
-  
-  int nhits = proto_segment.size();
-  CLHEP::HepMatrix matrix(2*nhits, 4);
-  int row = 0;
-  
-  const ME0EtaPartition* ens = theEnsamble.first;
-
-  for (auto ih = proto_segment.begin(); ih != proto_segment.end(); ++ih) {
-    const ME0RecHit& hit = (**ih);
-    const ME0EtaPartition* roll  = theEnsamble.second[hit.me0Id()];
-    GlobalPoint gp         = roll->toGlobal(hit.localPosition());
-    // Locat w,r,t, to the first layer;
-    LocalPoint  lp         = ens->toLocal(gp); 
-
-    float z = lp.z();
-    ++row;
-    matrix(row, 1) = 1.;
-    matrix(row, 3) = z;
-    ++row;
-    matrix(row, 2) = 1.;
-    matrix(row, 4) = z;
-  }
-  return matrix;
-}
-
-/* calculateError*/
-AlgebraicSymMatrix ME0SegAlgoMM::calculateError(){
-  
-  AlgebraicSymMatrix weights = this->weightMatrix();
-  AlgebraicMatrix A = this->derivativeMatrix();
-  
-  // (AT W A)^-1                                                                                                                                                         
-  // from http://www.phys.ufl.edu/~avery/fitting.html, part I                                                                                                            
-  int ierr;
-  AlgebraicSymMatrix result = weights.similarityT(A);
-  result.invert(ierr);
-
-  // blithely assuming the inverting never fails...                                                                                                                      
-  return result;
-}
-
-void ME0SegAlgoMM::flipErrors( AlgebraicSymMatrix& a ) { 
-    
-  // The ME0Segment needs the error matrix re-arranged to match
-  //  parameters in order (uz, vz, u0, v0) where uz, vz = slopes, u0, v0 = intercepts
-    
-  AlgebraicSymMatrix hold( a ); 
-    
-  // errors on slopes into upper left 
-  a(1,1) = hold(3,3); 
-  a(1,2) = hold(3,4); 
-  a(2,1) = hold(4,3); 
-  a(2,2) = hold(4,4); 
-    
-  // errors on positions into lower right 
-  a(3,3) = hold(1,1); 
-  a(3,4) = hold(1,2); 
-  a(4,3) = hold(2,1); 
-  a(4,4) = hold(2,2); 
-    
-  // must also interchange off-diagonal elements of off-diagonal 2x2 submatrices
-  a(4,1) = hold(2,3);
-  a(3,2) = hold(1,4);
-  a(2,3) = hold(4,1); // = hold(1,4)
-  a(1,4) = hold(3,2); // = hold(2,3)
-} 
-
-
diff --git a/RecoLocalMuon/GEMRecHit/src/ME0SegmentBuilder.cc~ b/RecoLocalMuon/GEMRecHit/src/ME0SegmentBuilder.cc~
deleted file mode 100644
index 10d61c7..0000000
--- a/RecoLocalMuon/GEMRecHit/src/ME0SegmentBuilder.cc~
+++ /dev/null
@@ -1,76 +0,0 @@
-#include <RecoLocalMuon/GEMRecHit/src/ME0SegmentBuilder.h>
-#include <DataFormats/MuonDetId/interface/ME0DetId.h>
-#include <DataFormats/GEMRecHit/interface/ME0RecHit.h>
-#include <Geometry/GEMGeometry/interface/ME0Geometry.h>
-#include <Geometry/GEMGeometry/interface/ME0EtaPartition.h>
-#include <RecoLocalMuon/GEMRecHit/src/ME0SegmentAlgorithm.h>
-#include <RecoLocalMuon/GEMRecHit/src/ME0SegmentBuilderPluginFactory.h>
-
-#include <FWCore/Utilities/interface/Exception.h>
-#include <FWCore/MessageLogger/interface/MessageLogger.h> 
-
-ME0SegmentBuilder::ME0SegmentBuilder(const edm::ParameterSet& ps) : geom_(0) {
-  
-  // Algo name
-  std::string algoName = ps.getParameter<std::string>("algo_name");
-  
-  LogDebug("ME0Segment|ME0")<< "ME0SegmentBuilder algorithm name: " << algoName;
-  
-  // SegAlgo parameter set
-  edm::ParameterSet segAlgoPSet = ps.getParameter<edm::ParameterSet>("algo_pset");
-  
-  // Ask factory to build this algorithm, giving it appropriate ParameterSet  
-  algo = ME0SegmentBuilderPluginFactory::get()->create(algoName, segAlgoPSet);
-  
-}
-ME0SegmentBuilder::~ME0SegmentBuilder() {
-  delete algo;
-}
-
-void ME0SegmentBuilder::build(const ME0RecHitCollection* recHits, ME0SegmentCollection& oc) {
-  	
-  LogDebug("ME0Segment|ME0")<< "Total number of rechits in this event: " << recHits->size();
-  
-  // Let's define the ensemble of ME0 devices having the same region, chambers number (phi), and eta partition
-  // and layer run from 1 to number of layer. This is not the definition of one chamber... and indeed segments
-  // could in principle run in different way... The concept of the DetLayer would be more appropriate...
-
-  std::map<uint32_t, std::vector<ME0RecHit*> > ensembleRH;
-    
-  // Loop on the ME0 rechit and select the different ME0 Ensemble
-  for(ME0RecHitCollection::const_iterator it2 = recHits->begin(); it2 != recHits->end(); it2++) {        
-    ME0DetId id(it2->me0Id().region(),1,it2->me0Id().chamber(),it2->me0Id().roll());
-    std::vector<ME0RecHit* > pp = ensembleRH[id.rawId()];
-    pp.push_back(it2->clone());
-    ensembleRH[id.rawId()]=pp;
-  }
-  
-  for(auto enIt=ensembleRH.begin(); enIt != ensembleRH.end(); ++enIt) {
-    
-    std::vector<const ME0RecHit*> me0RecHits;
-    std::map<uint32_t,const ME0EtaPartition* > ens;
-
-    const ME0EtaPartition* firstlayer = geom_->etaPartition(enIt->first);
-    for(auto rechit = enIt->second.begin(); rechit != enIt->second.end(); rechit++) {
-      me0RecHits.push_back(*rechit);
-      ens[(*rechit)->me0Id()]=geom_->etaPartition((*rechit)->me0Id());
-    }    
-    ME0SegmentAlgorithm::ME0Ensamble ensamble(std::pair<const ME0EtaPartition*, std::map<uint32_t,const ME0EtaPartition *> >(firstlayer,ens));
-    
-    //LogDebug("ME0Segment|ME0") << "found " << me0RecHits.size() << " rechits in chamber " << *enIt;
-    
-    // given the chamber select the appropriate algo... and run it
-    std::vector<ME0Segment> segv = algo->run(ensamble, me0RecHits);
-    ME0DetId mid(enIt->first);
-    LogDebug("ME0Segment|ME0") << "found " << me0RecHits.size() << " rechits in chamber " << mid;
-    LogDebug("ME0Segment|ME0") << "found " << segv.size() << " segments in chamber " << mid;
-    
-    // Add the segments to master collection
-    oc.put(mid, segv.begin(), segv.end());
-  }
-}
-
-void ME0SegmentBuilder::setGeometry(const ME0Geometry* geom) {
-  geom_ = geom;
-}
-
diff --git a/RecoMuon/DetLayers/src/MuonCSCDetLayerGeometryBuilder.cc~ b/RecoMuon/DetLayers/src/MuonCSCDetLayerGeometryBuilder.cc~
deleted file mode 100644
index f7790fc..0000000
--- a/RecoMuon/DetLayers/src/MuonCSCDetLayerGeometryBuilder.cc~
+++ /dev/null
@@ -1,153 +0,0 @@
-#include <RecoMuon/DetLayers/src/MuonCSCDetLayerGeometryBuilder.h>
-
-#include <RecoMuon/DetLayers/interface/MuRingForwardDoubleLayer.h>
-#include <RecoMuon/DetLayers/interface/MuDetRing.h>
-#include <DataFormats/MuonDetId/interface/CSCDetId.h>
-#include <Geometry/CommonDetUnit/interface/GeomDet.h>
-
-#include <Utilities/General/interface/precomputed_value_sort.h>
-#include <Geometry/CommonDetUnit/interface/DetSorting.h>
-
-#include <FWCore/MessageLogger/interface/MessageLogger.h>
-
-#include <iostream>
-
-using namespace std;
-
-pair<vector<DetLayer*>, vector<DetLayer*> > 
-MuonCSCDetLayerGeometryBuilder::buildLayers(const CSCGeometry& geo) {
-
-  vector<DetLayer*> result[2]; // one for each endcap
-  
-  for(int i=0; i<2; i++) {        
-    
-    int endcap = i+1;
-    
-    // ME/1/1a (= station 1, ring 4) and ME/1/1b (= station 1, ring 1)
-    {
-      vector<int> rings;
-      rings.push_back(4);
-      rings.push_back(1);
-      
-      MuRingForwardDoubleLayer* layer = buildLayer(endcap, 1, rings, geo);          
-      if (layer) result[i].push_back(layer);  
-    }
-    
-    // ME/1/2 and 1/3 (= station 1, ring 2 and 3)
-    {
-      vector<int> rings;
-      rings.push_back(2);
-      rings.push_back(3);
-      
-      MuRingForwardDoubleLayer* layer = buildLayer(endcap, 1, rings, geo);          
-      if (layer) result[i].push_back(layer);  
-    }    
-    
-    // Stations 2,3,4
-    for(int station = 2; station <= CSCDetId::maxStationId(); station++) {
-      vector<int> rings;      
-      for(int ring = CSCDetId::minRingId(); ring <= CSCDetId::maxRingId(); ring++) {
-        rings.push_back(ring);
-      }
-      MuRingForwardDoubleLayer* layer = buildLayer(endcap, station, rings, geo);          
-      if (layer) result[i].push_back(layer);
-    }
-  }
-  pair<vector<DetLayer*>, vector<DetLayer*> > res_pair(result[0], result[1]); 
-  return res_pair;
-}
-
-MuRingForwardDoubleLayer* MuonCSCDetLayerGeometryBuilder::buildLayer(int endcap,
-                                                               int station,
-                                                               vector<int>& rings,
-                                                               const CSCGeometry& geo) {
-  const std::string metname = "Muon|RecoMuon|RecoMuonDetLayers|MuonCSCDetLayerGeometryBuilder";
-  MuRingForwardDoubleLayer* result=0;
-  
-  vector<const ForwardDetRing*> frontRings, backRings;
-  
-  for (vector<int>::iterator ring = rings.begin(); ring!=rings.end(); ring++) {    
-    vector<const GeomDet*> frontGeomDets, backGeomDets;
-    for(int chamber = CSCDetId::minChamberId(); chamber <= CSCDetId::maxChamberId(); chamber++) {
-      CSCDetId detId(endcap, station, (*ring), chamber, 0);
-      const GeomDet* geomDet = geo.idToDet(detId);
-      // we sometimes loop over more chambers than there are in ring
-      bool isInFront = isFront(station, *ring, chamber);
-      if(geomDet != 0)
-      {
-        if(isInFront)
-        {
-          frontGeomDets.push_back(geomDet);
-        }
-        else
-        {
-          backGeomDets.push_back(geomDet);
-        }
-        LogTrace(metname) << "get CSC chamber "
-                          <<  CSCDetId(endcap, station, (*ring), chamber, 0)
-                          << " at R=" << geomDet->position().perp()
-                          << ", phi=" << geomDet->position().phi()
-                          << ", z= " << geomDet->position().z() 
-                          << " isFront? " << isInFront;
-      }
-    }
-
-    if(!backGeomDets.empty())
-    {
-      backRings.push_back(makeDetRing(backGeomDets));
-    }
-
-    if(!frontGeomDets.empty())
-    {
-      frontRings.push_back(makeDetRing(frontGeomDets));
-      assert(!backGeomDets.empty());
-      float frontz = frontRings[0]->position().z();
-      float backz  = backRings[0]->position().z();
-      assert(fabs(frontz) < fabs(backz));
-    }
-  }
-  
-  // How should they be sorted?
-  //    precomputed_value_sort(muDetRods.begin(), muDetRods.end(), geomsort::ExtractZ<GeometricSearchDet,float>());
-  result = new MuRingForwardDoubleLayer(frontRings, backRings);  
-  LogTrace(metname) << "New MuRingForwardLayer with " << frontRings.size() 
-                    << " and " << backRings.size()
-                    << " rings, at Z " << result->position().z()
-                    << " R1: " << result->specificSurface().innerRadius()
-                    << " R2: " << result->specificSurface().outerRadius(); 
-  return result;
-}
-
-
-bool MuonCSCDetLayerGeometryBuilder::isFront(int station, int ring, int chamber)
-{
-  bool result = false;
-  
-  bool isOverlapping = !(station == 1 && ring == 3);
-  // not overlapping means back
-  if(isOverlapping)
-  {
-    bool isEven = (chamber%2==0);
-    // odd chambers are bolted to the iron, which faces
-    // forward in 1&2, backward in 3&4, so...
-    result = (station<3) ? isEven : !isEven;
-  }
-  return result;
-}
-
-
-
-MuDetRing * MuonCSCDetLayerGeometryBuilder::makeDetRing(vector<const GeomDet*> & geomDets)
-{
-    const std::string metname = "Muon|RecoMuon|RecoMuonDetLayers|MuonCSCDetLayerGeometryBuilder";
-
-
-    precomputed_value_sort(geomDets.begin(), geomDets.end(), geomsort::DetPhi());
-    MuDetRing * result = new MuDetRing(geomDets);
-    LogTrace(metname) << "New MuDetRing with " << geomDets.size()
-                        << " chambers at z="<< result->position().z()
-                        << " R1: " << result->specificSurface().innerRadius()
-                        << " R2: " << result->specificSurface().outerRadius();
-    return result;
-}
-
diff --git a/RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.cc~ b/RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.cc~
deleted file mode 100644
index af40681..0000000
--- a/RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.cc~
+++ /dev/null
@@ -1,235 +0,0 @@
-#include <RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.h>
-
-#include <DataFormats/MuonDetId/interface/ME0DetId.h>
-#include <Geometry/CommonDetUnit/interface/GeomDet.h>
-//#include <RecoMuon/DetLayers/interface/MuRingForwardDoubleLayer.h>
-#include <RecoMuon/DetLayers/interface/MuRingForwardLayer.h>
-#include <RecoMuon/DetLayers/interface/MuRodBarrelLayer.h>
-#include <RecoMuon/DetLayers/interface/MuDetRing.h>
-#include <RecoMuon/DetLayers/interface/MuDetRod.h>
-
-#include <Utilities/General/interface/precomputed_value_sort.h>
-#include <Geometry/CommonDetUnit/interface/DetSorting.h>
-#include "Utilities/BinningTools/interface/ClusterizingHistogram.h"
-
-#include <FWCore/MessageLogger/interface/MessageLogger.h>
-
-#include <iostream>
-
-using namespace std;
-
-MuonME0DetLayerGeometryBuilder::~MuonME0DetLayerGeometryBuilder() {
-}
-
-
-// Builds the forward (first) and backward (second) layers - NOTE: Currently just one layer, all 'front'
-pair<vector<DetLayer*>, vector<DetLayer*> > 
-MuonME0DetLayerGeometryBuilder::buildEndcapLayers(const ME0Geometry& geo) {
-  
-  vector<DetLayer*> result[2];
-  const std::string metname = "Muon|RecoMuon|RecoMuonDetLayers|MuonME0DetLayerGeometryBuilder";
-  LogTrace(metname) << "Starting endcaplayers ";
-
-  for (int endcap = -1; endcap<=1; endcap+=2) {
-    int iendcap = (endcap==1) ? 0 : 1; // +1: forward, -1: backward
-
-    //No stations defined for ME0
-    //for(int station = ME0DetId::minStationId; station < ME0DetId::maxStationId; ++station) {
-
-    //Changing to not be dependent on layers...
-    vector<int> rolls;      
-    std::vector<int> rings;
-    std::vector<int> chambers;
-	
-      // for(int layer = ME0DetId::minLayerId; layer <= ME0DetId::maxLayerId; ++layer) { 
-      // 	vector<int> rolls;      
-      // 	std::vector<int> rings;
-      // 	std::vector<int> chambers;
-	
-	//No rings defined for ME0
-	// for(int ring = ME0DetId::minRingId; ring <= ME0DetId::maxRingId; ++ring) {
-	//   rings.push_back(ring);
-	// }
-
-	for(int roll = ME0DetId::minRollId+1; roll <= ME0DetId::maxRollId; ++roll) {
-	  rolls.push_back(roll);
-	}
-	for(int chamber = ME0DetId::minChamberId+1; chamber <= ME0DetId::maxChamberId; chamber++ ){
-	  chambers.push_back(chamber);
-	}
-
-	LogTrace(metname) << "Encap =  " << endcap
-	  //<< "Layer =  " << layer
-			  << "Chambers =  " << chambers.size()
-			  << "Rolls =  " << rolls.size();
-
-
-	//MuRingForwardDoubleLayer* ringLayer = buildLayer(endcap, rings, station, layer, chambers, rolls, geo);          
-	//MuRingForwardDoubleLayer* ringLayer = buildLayer(endcap, layer, chambers, rolls, geo);          
-	//MuRingForwardLayer* ringLayer = buildLayer(endcap, layer, chambers, rolls, geo);          
-	MuRingForwardLayer* ringLayer = buildLayer(endcap, chambers, rolls, geo);          
-
-	if (ringLayer) result[iendcap].push_back(ringLayer);
-
-      // }
-
-      //}
-  }
-  pair<vector<DetLayer*>, vector<DetLayer*> > res_pair(result[0], result[1]); 
-
-  return res_pair;
-
-}
-
-
-
-
-// MuonME0DetLayerGeometryBuilder::buildLayer(int endcap,vector<int>& rings, int station,
-// 					   int layer,
-// 					   vector<int>& chambers,
-// 					   vector<int>& rolls,
-// 					   const ME0Geometry& geo) {
-
-//MuRingForwardDoubleLayer* 
-
-
-// MuRingForwardLayer* 
-// MuonME0DetLayerGeometryBuilder::buildLayer(int endcap, int layer,
-// 					   vector<int>& chambers,
-// 					   vector<int>& rolls,
-// 					   const ME0Geometry& geo) {
-
-MuRingForwardLayer* 
-MuonME0DetLayerGeometryBuilder::buildLayer(int endcap,
-					   vector<int>& chambers,
-					   vector<int>& rolls,
-					   const ME0Geometry& geo) {
-
-  const std::string metname = "Muon|RecoMuon|RecoMuonDetLayers|MuonME0DetLayerGeometryBuilder";
-  //MuRingForwardDoubleLayer * result = 0;
-  MuRingForwardLayer * result = 0;
-  vector<const ForwardDetRing*> frontRings, backRings;
-
-  LogTrace(metname) << "Starting to Build Layer ";
-//  for (std::vector<int>::iterator ring=rings.begin(); ring!=rings.end();ring++){ 
-
-  //No rings defined in ME0
-  //for (std::vector<int>::iterator ring=rings.begin(); ring!=rings.end()-2;ring++){ 
-
-    for (vector<int>::iterator roll = rolls.begin(); roll!=rolls.end(); roll++) {    
-      LogTrace(metname) << "On a roll ";
-      vector<const GeomDet*> frontDets, backDets;
-
-      for(std::vector<int>::iterator chamber=chambers.begin(); chamber<chambers.end(); chamber++) {
-	//for(std::vector<int>::iterator chamber=chambers.begin(); chamber<chambers.end(); chamber++) {
-
-	//LogTrace(metname) << "On a chamber ";
-	//No rings or stations in ME0
-	//ME0DetId me0Id(endcap,(*ring), station,layer,(*chamber), (*roll));
-      //ME0DetId me0Id(endcap,layer,(*chamber), (*roll));
-	//for (int i =1; i<=6;++i){
-
-	  //ME0DetId me0Id(endcap,1,(*chamber), (*roll));
-	//ME0DetId me0Id(endcap,0,(*chamber), (*roll));
-	//ME0DetId me0Id(endcap,0,(*chamber), (*roll));
-      ME0DetId me0Id(endcap,1,(*chamber), (*roll));
-
-      LogTrace(metname) << "Have an me0Id :"
-			<<me0Id;
-
-
- 	  const GeomDet* geomDet = geo.idToDet(me0Id);
-	  LogTrace(metname) << "Got Geometry with id: "
-			    <<geomDet;
-	  
-	  if (geomDet !=0) {
-	  LogTrace(metname) << "In Geo step";
-	    bool isInFront = isFront(me0Id);
-	  LogTrace(metname) << "Getting bool";
-	    if(isInFront)
-            {
-              frontDets.push_back(geomDet);
-	  LogTrace(metname) << "Is in front";
-            }
-            else 
-            {
-              backDets.push_back(geomDet);
-            }
-	    LogTrace(metname) << "get ME0 Endcap roll "
-			      << me0Id
-                              << (isInFront ? "front" : "back ")
-			      << " at R=" << geomDet->position().perp()
-			      << ", phi=" << geomDet->position().phi()
-                              << ", Z=" << geomDet->position().z();
-	  }
-	  //}
-      }
-
-      if (frontDets.size()!=0) {
-	precomputed_value_sort(frontDets.begin(), frontDets.end(), geomsort::DetPhi());
-	frontRings.push_back(new MuDetRing(frontDets));
-	LogTrace(metname) << "New front ring with " << frontDets.size()
-			  << " chambers at z="<< frontRings.back()->position().z();
-      }
-      if (backDets.size()!=0) {
-        precomputed_value_sort(backDets.begin(), backDets.end(), geomsort::DetPhi());
-        backRings.push_back(new MuDetRing(backDets));
-        LogTrace(metname) << "New back ring with " << backDets.size()
-                          << " chambers at z="<< backRings.back()->position().z();
-      }
-
-    }
-
-    //}
-
-  // How should they be sorted?
-  //    precomputed_value_sort(muDetRods.begin(), muDetRods.end(), geomsort::ExtractZ<GeometricSearchDet,float>());                                   
-
-
-    //if(backRings.size()!=0 && frontRings.size()!=0) result = new MuRingForwardDoubleLayer(frontRings, backRings);
-    
-    //Using a single layer now, did a hack where we'll only fill the frontRings vector
-    LogTrace(metname) << "About to make a MuRingForwardLayer";
-    result = new MuRingForwardLayer(frontRings);
-    
-  //result = 0;
-  
-  LogTrace(metname) << "New MuRingForwardLayer with " << frontRings.size()
-                    << " and " << backRings.size()
-                    << " rings, at Z " << result->position().z()
-                    << " R1: " << result->specificSurface().innerRadius()
-                    << " R2: " << result->specificSurface().outerRadius();
-  
-  return result;
-
-}
-
-
-bool MuonME0DetLayerGeometryBuilder::isFront(const ME0DetId & me0Id)
-{
-
-  //ME0s do not currently have an arrangement of which are front and which are back, going to always return true
-
-  bool result = true;
-  return result;
- 
-  // bool result = false;
-  // int chamber = me0Id.chamber();
-  // if(chamber%2 == 0) result = !result;
-  // return result;
-
-}
-
-MuDetRing * MuonME0DetLayerGeometryBuilder::makeDetRing(vector<const GeomDet*> & geomDets)
-{
-    const std::string metname = "Muon|RecoMuon|RecoMuonDetLayers|MuonME0DetLayerGeometryBuilder";
-
-
-    precomputed_value_sort(geomDets.begin(), geomDets.end(), geomsort::DetPhi());
-    MuDetRing * result = new MuDetRing(geomDets);
-    LogTrace(metname) << "New MuDetRing with " << geomDets.size()
-                        << " chambers at z="<< result->position().z()
-                        << " R1: " << result->specificSurface().innerRadius()
-                        << " R2: " << result->specificSurface().outerRadius();
-    return result;
-}
diff --git a/RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.h~ b/RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.h~
deleted file mode 100644
index 6e77910..0000000
--- a/RecoMuon/DetLayers/src/MuonME0DetLayerGeometryBuilder.h~
+++ /dev/null
@@ -1,42 +0,0 @@
-#ifndef MuonME0DetLayerGeometryBuilder_h
-#define MuonME0DetLayerGeometryBuilder_h
-
-/** \class MuonME0DetLayerGeometryBuilder
- *
- *  Build the ME0 DetLayers.
- *
- *  \author D. Nash
- */
-
-class DetLayer;
-//class MuRingForwardDoubleLayer;
-class MuRingForwardLayer;
-//class MuRodBarrelLayer;
-class MuDetRing;
-
-
-#include <Geometry/GEMGeometry/interface/ME0Geometry.h>
-#include "RecoMuon/DetLayers/interface/MuDetRod.h"
-#include <vector>
-
-class MuonME0DetLayerGeometryBuilder {
- public:
-  /// Constructor (disabled, only static access is allowed)
-  MuonME0DetLayerGeometryBuilder(){}
-
-  /// Destructor
-  virtual ~MuonME0DetLayerGeometryBuilder();
-  
-  /// Builds the forward (+Z, return.first) and backward (-Z, return.second) layers.
-  /// Both vectors are sorted inside-out
-  static std::pair<std::vector<DetLayer*>, std::vector<DetLayer*> > buildEndcapLayers(const ME0Geometry& geo);
-    
- private:
-  //static MuRingForwardDoubleLayer* buildLayer(int endcap,int layer,std::vector<int>& chambers,std::vector<int>& rolls,const ME0Geometry& geo);          
-  static MuRingForwardLayer* buildLayer(int endcap,int layer,std::vector<int>& chambers,std::vector<int>& rolls,const ME0Geometry& geo);          
-  static bool isFront(const ME0DetId & me0Id);
-  static MuDetRing * makeDetRing(std::vector<const GeomDet*> & geomDets);
-  
-};
-#endif
-
diff --git a/RecoMuon/MeasurementDet/interface/MuonDetLayerMeasurements.h~ b/RecoMuon/MeasurementDet/interface/MuonDetLayerMeasurements.h~
deleted file mode 100644
index 742c678..0000000
--- a/RecoMuon/MeasurementDet/interface/MuonDetLayerMeasurements.h~
+++ /dev/null
@@ -1,169 +0,0 @@
-#ifndef MeasurementDet_MuonDetLayerMeasurements_H
-#define MeasurementDet_MuonDetLayerMeasurements_H
-
-/** \class MuonDetLayerMeasurements
- *  The class to access recHits and TrajectoryMeasurements from DetLayer.  
- *
- *  \author C. Liu, R. Bellan, N. Amapane
- *  \modified by C. Calabria to include GEMs
- *  \modified by D. Nash to include ME0s
- *
- */
-
-#include "FWCore/Framework/interface/Event.h"
-#include "TrackingTools/TrajectoryState/interface/TrajectoryStateOnSurface.h"
-#include "TrackingTools/GeomPropagators/interface/Propagator.h"
-#include "TrackingTools/DetLayers/interface/MeasurementEstimator.h"
-#include "RecoMuon/TransientTrackingRecHit/interface/MuonTransientTrackingRecHit.h"
-//#include "TrackingTools/ementDet/interface/TrajectoryMeasurement.h"
-#include "TrackingTools/MeasurementDet/interface/TrajectoryMeasurementGroup.h"
-#include "DataFormats/DTRecHit/interface/DTRecSegment4DCollection.h"
-#include "DataFormats/CSCRecHit/interface/CSCSegmentCollection.h"
-#include "DataFormats/RPCRecHit/interface/RPCRecHitCollection.h"
-#include "DataFormats/GEMRecHit/interface/GEMRecHitCollection.h"
-#include "DataFormats/GEMRecHit/interface/ME0RecHitCollection.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include <vector>
-
-class DetLayer;
-class GeomDet;
-class TrajectoryMeasurement;
-
-
-//FIXME: these typedefs MUST GO inside the scope of MuonDetLayerMeasurements
-typedef std::vector<TrajectoryMeasurement>          MeasurementContainer;
-typedef std::pair<const GeomDet*,TrajectoryStateOnSurface> DetWithState;
-
-
-class MuonDetLayerMeasurements {
- public:
-  typedef MuonTransientTrackingRecHit::MuonRecHitContainer MuonRecHitContainer;
-
-  MuonDetLayerMeasurements(edm::InputTag dtlabel,
-			   edm::InputTag csclabel,
-			   edm::InputTag rpclabel,
-			   edm::InputTag gemlabel,
-			   edm::InputTag me0label,
-			   bool enableDT = true,
-			   bool enableCSC = true,
-			   bool enableRPC = true,
-			   bool enableGEM = true,
-			   bool enableME0 = true);
-  
-  virtual ~MuonDetLayerMeasurements();
-  
-  // for a given det and state.  Not clear when the fastMeasurements below
-  //  should be used, since it isn't passed a GeomDet
-  MeasurementContainer
-    measurements( const DetLayer* layer,
-                  const GeomDet * det,
-                  const TrajectoryStateOnSurface& stateOnDet,
-                  const MeasurementEstimator& est,
-                  const edm::Event& iEvent);
-
-  /// returns TMeasurements in a DetLayer compatible with the TSOS.
-  MeasurementContainer
-    measurements( const DetLayer* layer,
-		  const TrajectoryStateOnSurface& startingState,
-		  const Propagator& prop,
-		  const MeasurementEstimator& est,
-		  const edm::Event& iEvent);
-
-  /// faster version in case the TrajectoryState on the surface of the GeomDet is already available
-  MeasurementContainer
-    fastMeasurements( const DetLayer* layer,
-		      const TrajectoryStateOnSurface& theStateOnDet,
-		      const TrajectoryStateOnSurface& startingState,
-		      const Propagator& prop,
-		      const MeasurementEstimator& est,
-		      const edm::Event& iEvent);
-
-  /// returns TMeasurements in a DetLayer compatible with the TSOS.
-  MeasurementContainer
-    measurements( const DetLayer* layer,
-		  const TrajectoryStateOnSurface& startingState,
-		  const Propagator& prop,
-		  const MeasurementEstimator& est);
-
-  /// faster version in case the TrajectoryState on the surface of the GeomDet is already available
-  MeasurementContainer
-    fastMeasurements( const DetLayer* layer,
-		      const TrajectoryStateOnSurface& theStateOnDet,
-		      const TrajectoryStateOnSurface& startingState,
-		      const Propagator& prop,
-		      const MeasurementEstimator& est);
-
-  std::vector<TrajectoryMeasurementGroup>
-    groupedMeasurements( const DetLayer* layer,
-                  const TrajectoryStateOnSurface& startingState,
-                  const Propagator& prop,
-                  const MeasurementEstimator& est,
-                  const edm::Event& iEvent);
-
-  std::vector<TrajectoryMeasurementGroup>
-    groupedMeasurements( const DetLayer* layer,
-                  const TrajectoryStateOnSurface& startingState,
-                  const Propagator& prop,
-                  const MeasurementEstimator& est);
- 
-  void setEvent(const edm::Event &);  
-
-  /// returns the rechits which are on the layer
-  MuonRecHitContainer recHits(const DetLayer* layer, const edm::Event& iEvent);
-
-  /// returns the rechits which are on the layer
-  MuonRecHitContainer recHits(const DetLayer* layer);
-
-
- private:
-
-  /// obtain TrackingRecHits from a DetLayer
-  MuonRecHitContainer recHits(const GeomDet*, const edm::Event& iEvent);
-
-  /// check that the event is set, and throw otherwise
-  void checkEvent() const;
-
-  edm::InputTag theDTRecHitLabel;
-  edm::InputTag theCSCRecHitLabel;
-  edm::InputTag theRPCRecHitLabel;
-  edm::InputTag theGEMRecHitLabel;
-  edm::InputTag theME0RecHitLabel;
-
-  bool enableDTMeasurement;
-  bool enableCSCMeasurement;
-  bool enableRPCMeasurement;
-  bool enableGEMMeasurement;
-  bool enableME0Measurement;
-  
-  // caches that should get filled once per event
-  edm::Handle<DTRecSegment4DCollection> theDTRecHits;
-  edm::Handle<CSCSegmentCollection>     theCSCRecHits;
-  edm::Handle<RPCRecHitCollection>      theRPCRecHits;
-  edm::Handle<GEMRecHitCollection>      theGEMRecHits;
-  edm::Handle<ME0RecHitCollection>      theME0RecHits;
-
-  void checkDTRecHits();
-  void checkCSCRecHits();
-  void checkRPCRecHits();
-  void checkGEMRecHits();
-  void checkME0RecHits();
-
-  // keeps track of which event the cache holds
-  edm::EventID theDTEventID;
-  edm::EventID theCSCEventID;
-  edm::EventID theRPCEventID;
-  edm::EventID theGEMEventID;
-  edm::EventID theME0EventID;
-
-  const edm::Event* theEvent;   
-
-  // strings to uniquely identify current process
-  std::string theDTCheckName;
-  std::string theRPCCheckName;
-  std::string theCSCCheckName;
-  std::string theGEMCheckName;
-  std::string theME0CheckName;
-};
-#endif
-
diff --git a/RecoMuon/MeasurementDet/src/MuonDetLayerMeasurements.cc~ b/RecoMuon/MeasurementDet/src/MuonDetLayerMeasurements.cc~
deleted file mode 100644
index 6317dcf..0000000
--- a/RecoMuon/MeasurementDet/src/MuonDetLayerMeasurements.cc~
+++ /dev/null
@@ -1,445 +0,0 @@
-/** \class MuonDetLayerMeasurements
- *  The class to access recHits and TrajectoryMeasurements from DetLayer.
- *
- *  \author C. Liu, R. Bellan, N. Amapane
- *  \modified by C. Calabria to include GEMs
- *  \modified by D. Nash to include ME0s
- *
- */
-
-#include "RecoMuon/MeasurementDet/interface/MuonDetLayerMeasurements.h"
-
-#include "TrackingTools/PatternTools/interface/TrajectoryMeasurement.h" 
-#include "TrackingTools/DetLayers/interface/DetLayer.h"
-
-#include "TrackingTools/PatternTools/interface/TrajMeasLessEstim.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ServiceRegistry/interface/Service.h"
-#include "FWCore/Services/interface/UpdaterService.h"
-
-
-typedef MuonTransientTrackingRecHit::MuonRecHitPointer MuonRecHitPointer;
-typedef MuonTransientTrackingRecHit::MuonRecHitContainer MuonRecHitContainer;
-
-
-
-MuonDetLayerMeasurements::MuonDetLayerMeasurements(edm::InputTag dtlabel, 
-						   edm::InputTag csclabel, 
-						   edm::InputTag rpclabel,
-						   edm::InputTag gemlabel,
-						   edm::InputTag me0label,
-						   bool enableDT, bool enableCSC, bool enableRPC, bool enableGEM, bool enableME0): 
-  theDTRecHitLabel(dtlabel),
-  theCSCRecHitLabel(csclabel),
-  theRPCRecHitLabel(rpclabel),
-  theGEMRecHitLabel(gemlabel),
-  theME0RecHitLabel(me0label),
-  enableDTMeasurement(enableDT),
-  enableCSCMeasurement(enableCSC),
-  enableRPCMeasurement(enableRPC),
-  enableGEMMeasurement(enableGEM),
-  enableME0Measurement(enableME0),
-  theDTRecHits(),
-  theCSCRecHits(),
-  theRPCRecHits(),
-  theGEMRecHits(),
-  theME0RecHits(),
-  theDTEventID(),
-  theCSCEventID(),
-  theRPCEventID(),
-  theGEMEventID(),
-  theME0EventID(),
-  theEvent(0){
-	  static int procInstance(0);
-	  std::ostringstream sDT;
-	  sDT<<"MuonDetLayerMeasurements::checkDTRecHits::" << procInstance;
-	  theDTCheckName = sDT.str();
-	  std::ostringstream sRPC;
-	  sRPC<<"MuonDetLayerMeasurements::checkRPCRecHits::" << procInstance;
-	  theRPCCheckName = sRPC.str();
-	  std::ostringstream sCSC;
-	  sCSC<<"MuonDetLayerMeasurements::checkCSCRecHits::" << procInstance;
-	  theCSCCheckName = sCSC.str();
-	  std::ostringstream sGEM;
-	  sGEM<<"MuonDetLayerMeasurements::checkGEMRecHits::" << procInstance;
-	  theGEMCheckName = sGEM.str();
-	  std::ostringstream sME0;
-	  sME0<<"MuonDetLayerMeasurements::checkME0RecHits::" << procInstance;
-	  theME0CheckName = sME0.str();
-	  procInstance++;
-  }
-
-MuonDetLayerMeasurements::~MuonDetLayerMeasurements(){}
-
-MuonRecHitContainer MuonDetLayerMeasurements::recHits(const GeomDet* geomDet, 
-			                              const edm::Event& iEvent)
-{
-  DetId geoId = geomDet->geographicalId();
-  theEvent = &iEvent;
-  MuonRecHitContainer result;
-
-  //LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "About to check subdets"<<std::endl;
-  if (geoId.subdetId()  == MuonSubdetId::DT) {
-    if(enableDTMeasurement) 
-    {
-      checkDTRecHits();
-    
-      // Create the ChamberId
-      DTChamberId chamberId(geoId.rawId());
-      // LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "(DT): "<<chamberId<<std::endl;
-    
-      // Get the DT-Segment which relies on this chamber
-      DTRecSegment4DCollection::range range = theDTRecHits->get(chamberId);
-    
-      // Create the MuonTransientTrackingRechit
-      for (DTRecSegment4DCollection::const_iterator rechit = range.first; 
-           rechit!=range.second;++rechit)
-        result.push_back(MuonTransientTrackingRecHit::specificBuild(geomDet,&*rechit));
-    }
-  }
-  
-  else if (geoId.subdetId()  == MuonSubdetId::CSC) {
-    if(enableCSCMeasurement)
-    {
-      checkCSCRecHits();
-
-      // Create the chamber Id
-      CSCDetId chamberId(geoId.rawId());
-      //    LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "(CSC): "<<chamberId<<std::endl;
-
-      // Get the CSC-Segment which relies on this chamber
-      CSCSegmentCollection::range range = theCSCRecHits->get(chamberId);
-    
-      // Create the MuonTransientTrackingRecHit
-      for (CSCSegmentCollection::const_iterator rechit = range.first; 
-           rechit!=range.second; ++rechit)
-        result.push_back(MuonTransientTrackingRecHit::specificBuild(geomDet,&*rechit)); 
-    }
-  }
-  
-  else if (geoId.subdetId()  == MuonSubdetId::RPC) {
-    if(enableRPCMeasurement)
-    {
-      checkRPCRecHits(); 
-
-      // Create the chamber Id
-      RPCDetId chamberId(geoId.rawId());
-      // LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "(RPC): "<<chamberId<<std::endl;
-    
-      // Get the RPC-Segment which relies on this chamber
-      RPCRecHitCollection::range range = theRPCRecHits->get(chamberId);
-    
-      // Create the MuonTransientTrackingRecHit
-      for (RPCRecHitCollection::const_iterator rechit = range.first; 
-           rechit!=range.second; ++rechit)
-        result.push_back(MuonTransientTrackingRecHit::specificBuild(geomDet,&*rechit));
-    }
-  }
-  else if (geoId.subdetId()  == MuonSubdetId::GEM) {
-    if(enableGEMMeasurement)
-    {
-      checkGEMRecHits(); 
-
-      // Create the chamber Id
-      GEMDetId chamberId(geoId.rawId());
-      // LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "(GEM): "<<chamberId<<std::endl;
-    
-      // Get the GEM-Segment which relies on this chamber
-      GEMRecHitCollection::range range = theGEMRecHits->get(chamberId);
-
-      // Create the MuonTransientTrackingRecHit
-      for (GEMRecHitCollection::const_iterator rechit = range.first; 
-           rechit!=range.second; ++rechit)
-        result.push_back(MuonTransientTrackingRecHit::specificBuild(geomDet,&*rechit));
-    }
-  }
-  else if (geoId.subdetId()  == MuonSubdetId::ME0) {
-    if(enableME0Measurement)
-    {
-      checkME0RecHits(); 
-
-      // Create the chamber Id
-      LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "raw id: "<<geoId.rawId()<<std::endl;
-      ME0DetId chamberId(geoId.rawId());
-      LogTrace("Muon|RecoMuon|MuonDetLayerMeasurements") << "(ME0): "<<chamberId<<std::endl;
-    
-      // Get the ME0-Segment which relies on this chamber
-      ME0RecHitCollection::range range = theME0RecHits->get(chamberId);
-
-      // Create the MuonTransientTrackingRecHit
-      for (ME0RecHitCollection::const_iterator rechit = range.first; 
-           rechit!=range.second; ++rechit)
-        result.push_back(MuonTransientTrackingRecHit::specificBuild(geomDet,&*rechit));
-    }
-  }
-  else {
-    // wrong type
-    throw cms::Exception("MuonDetLayerMeasurements") << "The DetLayer with det " << geoId.det() << " subdet " << geoId.subdetId() << " is not a valid Muon DetLayer. ";
-  }
-  return result;
-}
-
-
-void MuonDetLayerMeasurements::checkDTRecHits()
-{
-  checkEvent();
-  if (!edm::Service<UpdaterService>()->checkOnce(theDTCheckName)) return;
-
-  {
-    theDTEventID = theEvent->id();
-    theEvent->getByLabel(theDTRecHitLabel, theDTRecHits);
-  }
-  if(!theDTRecHits.isValid())
-  {
-    throw cms::Exception("MuonDetLayerMeasurements") << "Cannot get DT RecHits";
-  }
-}
-
-
-void MuonDetLayerMeasurements::checkCSCRecHits()
-{
-  checkEvent();
-  if (!edm::Service<UpdaterService>()->checkOnce(theCSCCheckName)) return;
-
-  {
-    theCSCEventID = theEvent->id();
-    theEvent->getByLabel(theCSCRecHitLabel, theCSCRecHits);
-  }
-  if(!theCSCRecHits.isValid())
-  {
-    throw cms::Exception("MuonDetLayerMeasurements") << "Cannot get CSC RecHits";
-  }
-}
-
-
-void MuonDetLayerMeasurements::checkRPCRecHits()
-{
-  checkEvent();
-  if (!edm::Service<UpdaterService>()->checkOnce(theRPCCheckName)) return;
-
-  {
-    theRPCEventID = theEvent->id();
-    theEvent->getByLabel(theRPCRecHitLabel, theRPCRecHits);
-  }
-  if(!theRPCRecHits.isValid())
-  {
-    throw cms::Exception("MuonDetLayerMeasurements") << "Cannot get RPC RecHits";
-  }
-}
-
-
-void MuonDetLayerMeasurements::checkGEMRecHits()
-{
-  checkEvent();
-  if (!edm::Service<UpdaterService>()->checkOnce(theGEMCheckName)) return;
-
-  {
-    theGEMEventID = theEvent->id();
-    theEvent->getByLabel(theGEMRecHitLabel, theGEMRecHits);
-  }
-  if(!theGEMRecHits.isValid())
-  {
-    throw cms::Exception("MuonDetLayerMeasurements") << "Cannot get GEM RecHits";
-  }
-}
-
-
-void MuonDetLayerMeasurements::checkME0RecHits()
-{
-  checkEvent();
-  if (!edm::Service<UpdaterService>()->checkOnce(theME0CheckName)) return;
-
-  {
-    theME0EventID = theEvent->id();
-    theEvent->getByLabel(theME0RecHitLabel, theME0RecHits);
-  }
-  if(!theME0RecHits.isValid())
-  {
-    throw cms::Exception("MuonDetLayerMeasurements") << "Cannot get ME0 RecHits";
-  }
-}
-
-
-///measurements method if already got the Event 
-MeasurementContainer
-MuonDetLayerMeasurements::measurements( const DetLayer* layer,
-					const TrajectoryStateOnSurface& startingState,
-					const Propagator& prop,
-					const MeasurementEstimator& est) {
-  checkEvent();
-  return measurements(layer, startingState, prop, est, *theEvent);
-}
-
-
-MeasurementContainer
-MuonDetLayerMeasurements::measurements(const DetLayer* layer,
-				       const TrajectoryStateOnSurface& startingState,
-				       const Propagator& prop,
-				       const MeasurementEstimator& est,
-				       const edm::Event& iEvent) {
-  
-  MeasurementContainer result;
-  
-  std::vector<DetWithState> dss = layer->compatibleDets(startingState, prop, est);
-  LogTrace("RecoMuon")<<"compatibleDets: "<<dss.size()<<std::endl;
-  
-  for(std::vector<DetWithState>::const_iterator detWithStateItr = dss.begin();
-      detWithStateItr != dss.end(); ++detWithStateItr){
-
-    MeasurementContainer detMeasurements 
-      = measurements(layer, detWithStateItr->first, 
-                     detWithStateItr->second, est, iEvent);
-    result.insert(result.end(), detMeasurements.begin(), detMeasurements.end());
-  }
-  
-  if (!result.empty()) sort( result.begin(), result.end(), TrajMeasLessEstim());
-  
-  return result;
-}
-
-
-MeasurementContainer
-MuonDetLayerMeasurements::measurements( const DetLayer* layer,
-					const GeomDet* det,
-					const TrajectoryStateOnSurface& stateOnDet,
-					const MeasurementEstimator& est,
-					const edm::Event& iEvent) {
-  MeasurementContainer result;
-  
-  // Get the Segments which relies on the GeomDet given by compatibleDets
-  MuonRecHitContainer muonRecHits = recHits(det, iEvent);
-  
-  // Create the Trajectory Measurement
-  for(MuonRecHitContainer::const_iterator rechit = muonRecHits.begin();
-      rechit != muonRecHits.end(); ++rechit) {
-
-    MeasurementEstimator::HitReturnType estimate = est.estimate(stateOnDet,**rechit);
-    LogTrace("RecoMuon")<<"Dimension: "<<(*rechit)->dimension()
-			<<" Chi2: "<<estimate.second<<std::endl;
-    if (estimate.first) {
-      result.push_back(TrajectoryMeasurement(stateOnDet, rechit->get(),
-					     estimate.second,layer));
-    }
-  }
-
-  if (!result.empty()) sort( result.begin(), result.end(), TrajMeasLessEstim());
-   
-  return result;
-}
-
-
-
-MeasurementContainer
-MuonDetLayerMeasurements::fastMeasurements( const DetLayer* layer,
-					    const TrajectoryStateOnSurface& theStateOnDet,
-					    const TrajectoryStateOnSurface& startingState,
-					    const Propagator& prop,
-					    const MeasurementEstimator& est,
-					    const edm::Event& iEvent) {
-  MeasurementContainer result;
-  MuonRecHitContainer rhs = recHits(layer, iEvent);
-  for (MuonRecHitContainer::const_iterator irh = rhs.begin(); irh!=rhs.end(); irh++) {
-    MeasurementEstimator::HitReturnType estimate = est.estimate(theStateOnDet, (**irh));
-    if (estimate.first)
-    {
-      result.push_back(TrajectoryMeasurement(theStateOnDet,(*irh).get(),
-                                             estimate.second,layer));
-    }
-  }
-
-  if (!result.empty()) {
-    sort( result.begin(), result.end(), TrajMeasLessEstim());
-  }
-
-  return result;
-}
-
-///fastMeasurements method if already got the Event
-MeasurementContainer
-MuonDetLayerMeasurements::fastMeasurements(const DetLayer* layer,
-					   const TrajectoryStateOnSurface& theStateOnDet,
-					   const TrajectoryStateOnSurface& startingState,
-					   const Propagator& prop,
-					   const MeasurementEstimator& est) {
-  checkEvent();
-  return fastMeasurements(layer, theStateOnDet, startingState, prop, est, *theEvent); 
-}
-
-
-std::vector<TrajectoryMeasurementGroup>
-MuonDetLayerMeasurements::groupedMeasurements(const DetLayer* layer,
-					      const TrajectoryStateOnSurface& startingState,
-					      const Propagator& prop,
-					      const MeasurementEstimator& est) {
-  checkEvent();
-  return groupedMeasurements(layer, startingState, prop,  est, *theEvent);
-}
-
-
-std::vector<TrajectoryMeasurementGroup>
-MuonDetLayerMeasurements::groupedMeasurements(const DetLayer* layer,
-					      const TrajectoryStateOnSurface& startingState,
-					      const Propagator& prop,
-					      const MeasurementEstimator& est,
-					      const edm::Event& iEvent) {
-  
-  std::vector<TrajectoryMeasurementGroup> result;
-  // if we want to use the concept of InvalidRecHits,
-  // we can reuse LayerMeasurements from TrackingTools/MeasurementDet
-  std::vector<DetGroup> groups(layer->groupedCompatibleDets(startingState, prop, est));
-
-  // this should be fixed either in RecoMuon/MeasurementDet/MuonDetLayerMeasurements or
-  // RecoMuon/DetLayers/MuRingForwardDoubleLayer
-  // and removed the reverse operation in StandAloneMuonFilter::findBestMeasurements
-
-  for (std::vector<DetGroup>::const_iterator grp=groups.begin(); grp!=groups.end(); ++grp) {
-    
-    std::vector<TrajectoryMeasurement> groupMeasurements;
-    for (DetGroup::const_iterator detAndStateItr=grp->begin();
-         detAndStateItr !=grp->end(); ++detAndStateItr) {
-
-      std::vector<TrajectoryMeasurement> detMeasurements 
-        = measurements(layer, detAndStateItr->det(), detAndStateItr->trajectoryState(), est, iEvent);
-      groupMeasurements.insert(groupMeasurements.end(), detMeasurements.begin(), detMeasurements.end());
-    }
-    
-    if (!groupMeasurements.empty()) 
-      std::sort( groupMeasurements.begin(), groupMeasurements.end(), TrajMeasLessEstim());  
-    
-    result.push_back(TrajectoryMeasurementGroup(groupMeasurements, *grp));
-  }
-
-  return result;
-}
-
-///set event
-void MuonDetLayerMeasurements::setEvent(const edm::Event& event) {
-  theEvent = &event;
-}
-
-
-void MuonDetLayerMeasurements::checkEvent() const {
-  if(!theEvent)
-    throw cms::Exception("MuonDetLayerMeasurements") << "The event has not been set";
-}
-
-MuonRecHitContainer MuonDetLayerMeasurements::recHits(const DetLayer* layer, 
-						      const edm::Event& iEvent) {
-  MuonRecHitContainer rhs;
-  
-  std::vector <const GeomDet*> gds = layer->basicComponents();
-
-  for (std::vector<const GeomDet*>::const_iterator igd = gds.begin(); 
-       igd != gds.end(); igd++) {
-    MuonRecHitContainer detHits = recHits(*igd, iEvent);
-    rhs.insert(rhs.end(), detHits.begin(), detHits.end());
-  }
-  return rhs;
-}
-
-MuonRecHitContainer MuonDetLayerMeasurements::recHits(const DetLayer* layer) 
-{
-  checkEvent();
-  return recHits(layer, *theEvent);
-}
-
diff --git a/RecoMuon/StandAloneMuonProducer/python/standAloneMuons_cfi.py~ b/RecoMuon/StandAloneMuonProducer/python/standAloneMuons_cfi.py~
deleted file mode 100644
index 34fb078..0000000
--- a/RecoMuon/StandAloneMuonProducer/python/standAloneMuons_cfi.py~
+++ /dev/null
@@ -1,112 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# The services
-from RecoMuon.TrackingTools.MuonServiceProxy_cff import *
-from RecoMuon.TrackingTools.MuonTrackLoader_cff import *
-
-standAloneMuons = cms.EDProducer(
-    "StandAloneMuonProducer",
-    MuonTrackLoaderForSTA,
-    MuonServiceProxy,
-    #                                 InputObjects = cms.InputTag("mergedStandAloneMuonSeeds"),
-    InputObjects = cms.InputTag("ancientMuonSeed"),
-    MuonTrajectoryBuilder = cms.string("Exhaustive"),
-    STATrajBuilderParameters = cms.PSet(
-        NavigationType = cms.string('Standard'),
-        SeedPosition = cms.string('in'),
-        SeedPropagator = cms.string('SteppingHelixPropagatorAny'),
-        
-        DoSeedRefit = cms.bool(False),
-        SeedTransformerParameters = cms.PSet(
-            Fitter = cms.string('KFFitterSmootherSTA'),
-            RescaleError = cms.double(100.0),
-            MuonRecHitBuilder = cms.string('MuonRecHitBuilder'),
-            Propagator = cms.string('SteppingHelixPropagatorAny'),
-            NMinRecHits = cms.uint32(2),
-            UseSubRecHits = cms.bool(False)
-            ),
-        
-        FilterParameters = cms.PSet(
-            FitDirection = cms.string('insideOut'),
-            EnableDTMeasurement = cms.bool(True),
-            DTRecSegmentLabel = cms.InputTag("dt4DSegments"),
-            EnableCSCMeasurement = cms.bool(True),
-            CSCRecSegmentLabel = cms.InputTag("cscSegments"),
-            EnableRPCMeasurement = cms.bool(True),
-            RPCRecSegmentLabel = cms.InputTag("rpcRecHits"),
-            EnableGEMMeasurement = cms.bool(False),
-            GEMRecSegmentLabel = cms.InputTag("gemRecHits"),
-            #EnableME0Measurement = cms.bool(False),
-            EnableME0Measurement = cms.bool(True),
-            ME0RecSegmentLabel = cms.InputTag("me0RecHits"),
-            NumberOfSigma = cms.double(3.0),
-            MaxChi2 = cms.double(1000.0),
-            Propagator = cms.string('SteppingHelixPropagatorAny'),
-            MuonTrajectoryUpdatorParameters = cms.PSet(MaxChi2 = cms.double(25.0),
-                                                       RescaleError = cms.bool(False),
-                                                       RescaleErrorFactor = cms.double(100.0),
-                                                       Granularity = cms.int32(0),
-                                                       UseInvalidHits = cms.bool(True),
-                                                       ExcludeRPCFromFit = cms.bool(False)
-                                                       )
-            ),
-        
-        DoBackwardFilter = cms.bool(True),
-        BWFilterParameters = cms.PSet(
-            FitDirection = cms.string('outsideIn'),
-            BWSeedType = cms.string('fromGenerator'),
-            EnableDTMeasurement = cms.bool(True),
-            DTRecSegmentLabel = cms.InputTag("dt4DSegments"),
-            EnableCSCMeasurement = cms.bool(True),
-            CSCRecSegmentLabel = cms.InputTag("cscSegments"),
-            EnableRPCMeasurement = cms.bool(True),
-            RPCRecSegmentLabel = cms.InputTag("rpcRecHits"),
-            EnableGEMMeasurement = cms.bool(False),
-            GEMRecSegmentLabel = cms.InputTag("gemRecHits"),
-            EnableME0Measurement = cms.bool(False),
-            ME0RecSegmentLabel = cms.InputTag("me0RecHits"),
-            NumberOfSigma = cms.double(3.0),
-            MaxChi2 = cms.double(100.0),
-            Propagator = cms.string('SteppingHelixPropagatorAny'),
-            MuonTrajectoryUpdatorParameters = cms.PSet(MaxChi2 = cms.double(25.0),
-                                                       RescaleError = cms.bool(False),
-                                                       RescaleErrorFactor = cms.double(100.0),
-                                                       Granularity = cms.int32(0),
-                                                       UseInvalidHits = cms.bool(True),
-                                                       ExcludeRPCFromFit = cms.bool(False)
-                                                       )
-            ),
-        DoRefit = cms.bool(False),
-        RefitterParameters = cms.PSet(
-            FitterName = cms.string('KFFitterSmootherSTA'),
-            NumberOfIterations = cms.uint32(3),
-            ForceAllIterations = cms.bool(False),
-            MaxFractionOfLostHits = cms.double(0.05),
-            RescaleError = cms.double(100.)
-            )
-        
-        )
-    )
-
-
-
-standAloneSETMuons = cms.EDProducer("StandAloneMuonProducer",
-                                    MuonTrackLoaderForSTA,
-                                    MuonServiceProxy,
-                                    InputObjects = cms.InputTag("SETMuonSeed"),
-                                    MuonTrajectoryBuilder = cms.string("DirectMuonTrajectoryBuilder"),
-                                    STATrajBuilderParameters = cms.PSet(
-    SeedTransformerParameters = cms.PSet(
-    Fitter = cms.string('KFFitterSmootherSTA'),
-    RescaleError = cms.double(1.0),
-    MuonRecHitBuilder = cms.string('MuonRecHitBuilder'),
-    Propagator = cms.string('SteppingHelixPropagatorAny'),
-    NMinRecHits = cms.uint32(2),
-    # careful - used with UseSegmentsInTrajectory in SETMuonSeed_cfi.py
-    #         UseSubRecHits = cms.bool(True)
-    UseSubRecHits = cms.bool(False)
-    )
-    )
-                                    )
-
-
diff --git a/RecoMuon/StandAloneTrackFinder/src/StandAloneTrajectoryBuilder.cc~ b/RecoMuon/StandAloneTrackFinder/src/StandAloneTrajectoryBuilder.cc~
deleted file mode 100644
index fd91063..0000000
--- a/RecoMuon/StandAloneTrackFinder/src/StandAloneTrajectoryBuilder.cc~
+++ /dev/null
@@ -1,494 +0,0 @@
-/** \class StandAloneTrajectoryBuilder
- *  Concrete class for the STA Muon reco 
- *
- *  $Date: 2011/12/22 20:28:34 $
- *  $Revision: 1.45 $
- *  \author R. Bellan - INFN Torino <riccardo.bellan@cern.ch>
- *  \author Stefano Lacaprara - INFN Legnaro
- *  \author D. Trocino - INFN Torino <daniele.trocino@to.infn.it>
- *  
- *  Modified by C. Calabria
- *  Modified by D. Nash
- */
-
-#include "RecoMuon/StandAloneTrackFinder/interface/StandAloneTrajectoryBuilder.h"
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "DataFormats/TrajectorySeed/interface/TrajectorySeed.h"
-#include "DataFormats/TrajectoryState/interface/PTrajectoryStateOnDet.h"
-#include "TrackingTools/TrajectoryState/interface/TrajectoryStateTransform.h"
-#include "DataFormats/TrajectorySeed/interface/PropagationDirection.h"
-
-#include "RecoMuon/StandAloneTrackFinder/interface/StandAloneMuonFilter.h"
-#include "RecoMuon/StandAloneTrackFinder/interface/StandAloneMuonBackwardFilter.h"
-#include "RecoMuon/StandAloneTrackFinder/interface/StandAloneMuonRefitter.h"
-
-#include "RecoMuon/TrackingTools/interface/MuonPatternRecoDumper.h"
-#include "RecoMuon/TrackingTools/interface/MuonServiceProxy.h"
-#include "RecoMuon/Navigation/interface/DirectMuonNavigation.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-#include "DataFormats/TrajectoryState/interface/PTrajectoryStateOnDet.h"
-#include "TrackingTools/TrajectoryState/interface/TrajectoryStateTransform.h"
-#include "TrackingTools/TrajectoryState/interface/TrajectoryStateOnSurface.h"
-#include "TrackingTools/TrajectoryState/interface/FreeTrajectoryState.h"
-#include "TrackingTools/DetLayers/interface/DetLayer.h"
-#include "Geometry/CommonDetUnit/interface/GeomDet.h"
-#include "TrackingTools/TrackRefitter/interface/SeedTransformer.h"
-
-
-using namespace edm;
-using namespace std;
-
-StandAloneMuonTrajectoryBuilder::StandAloneMuonTrajectoryBuilder(const ParameterSet& par, 
-								 const MuonServiceProxy* service):theService(service){
-  const std::string metname = "Muon|RecoMuon|StandAloneMuonTrajectoryBuilder";
-  
-  LogTrace(metname) << "constructor called" << endl;
-
-  // The navigation type:
-  // "Direct","Standard"
-  theNavigationType = par.getParameter<string>("NavigationType");
-  
-  // The inward-outward fitter (starts from seed state)
-  ParameterSet filterPSet = par.getParameter<ParameterSet>("FilterParameters");
-  filterPSet.addParameter<string>("NavigationType",theNavigationType);
-  theFilter = new StandAloneMuonFilter(filterPSet,theService);
-
-  // Fit direction
-  string seedPosition = par.getParameter<string>("SeedPosition");
-  
-  if (seedPosition == "in" ) theSeedPosition = recoMuon::in;
-  else if (seedPosition == "out" ) theSeedPosition = recoMuon::out;
-  else 
-    throw cms::Exception("StandAloneMuonFilter constructor") 
-      <<"Wrong seed position chosen in StandAloneMuonFilter::StandAloneMuonFilter ParameterSet"
-      << "\n"
-      << "Possible choices are:"
-      << "\n"
-      << "SeedPosition = in or SeedPosition = out";
-  
-  // Propagator for the seed extrapolation
-  theSeedPropagatorName = par.getParameter<string>("SeedPropagator");
-  
-  // Disable/Enable the backward filter
-  doBackwardFilter = par.getParameter<bool>("DoBackwardFilter");
-  
-  // Disable/Enable the refit of the trajectory
-  doRefit = par.getParameter<bool>("DoRefit");
-   
-  // Disable/Enable the refit of the trajectory seed
-  doSeedRefit = par.getParameter<bool>("DoSeedRefit");
-   
-  if(doBackwardFilter){
-    // The outward-inward fitter (starts from theFilter outermost state)
-    ParameterSet bwFilterPSet = par.getParameter<ParameterSet>("BWFilterParameters");
-    //  theBWFilter = new StandAloneMuonBackwardFilter(bwFilterPSet,theService); // FIXME
-    bwFilterPSet.addParameter<string>("NavigationType",theNavigationType);
-    theBWFilter = new StandAloneMuonFilter(bwFilterPSet,theService);
-    
-    theBWSeedType = bwFilterPSet.getParameter<string>("BWSeedType");
-  }
-
-  if(doRefit){
-    // The outward-inward fitter (starts from theBWFilter innermost state)
-    ParameterSet refitterPSet = par.getParameter<ParameterSet>("RefitterParameters");
-    theRefitter = new StandAloneMuonRefitter(refitterPSet, theService);
-  }
-
-  // The seed transformer (used to refit the seed and get the seed transient state)
-  //  ParameterSet seedTransformerPSet = par.getParameter<ParameterSet>("SeedTransformerParameters");
-  ParameterSet seedTransformerParameters = par.getParameter<ParameterSet>("SeedTransformerParameters");
-  theSeedTransformer = new SeedTransformer(seedTransformerParameters);
-
-}
-
-void StandAloneMuonTrajectoryBuilder::setEvent(const edm::Event& event){
-  theFilter->setEvent(event);
-   if(doBackwardFilter) theBWFilter->setEvent(event);
-}
-
-StandAloneMuonTrajectoryBuilder::~StandAloneMuonTrajectoryBuilder(){
-
-  LogTrace("Muon|RecoMuon|StandAloneMuonTrajectoryBuilder") 
-    << "StandAloneMuonTrajectoryBuilder destructor called" << endl;
-  
-  if(theFilter) delete theFilter;
-  if(doBackwardFilter && theBWFilter) delete theBWFilter;
-  if(doRefit && theRefitter) delete theRefitter;
-  if(theSeedTransformer) delete theSeedTransformer;
-}
-
-
-namespace {
-  struct Resetter {
-    StandAloneMuonFilter * mf;
-    explicit Resetter(StandAloneMuonFilter * imf) : mf(imf){}
-    ~Resetter() { if(mf) mf->reset();}
-  };
-}
-
-MuonTrajectoryBuilder::TrajectoryContainer 
-StandAloneMuonTrajectoryBuilder::trajectories(const TrajectorySeed& seed){ 
-  Resetter fwReset(filter());
-  Resetter bwReset(bwfilter());
-
-  const std::string metname = "Muon|RecoMuon|StandAloneMuonTrajectoryBuilder";
-  MuonPatternRecoDumper debug;
-
-  // Set the services for the seed transformer
-  theSeedTransformer->setServices(theService->eventSetup());
-
-  // the trajectory container. In principle starting from one seed we can
-  // obtain more than one trajectory. TODO: this feature is not yet implemented!
-  TrajectoryContainer trajectoryContainer;
-
-  PropagationDirection fwDirection = (theSeedPosition == recoMuon::in) ? alongMomentum : oppositeToMomentum;  
-  Trajectory trajectoryFW(seed,fwDirection);
-
-  TrajectoryStateOnSurface lastTSOS;
-  DetId lastDetId;
-
-  vector<Trajectory> seedTrajectories;
-
-  if(doSeedRefit) {
-    seedTrajectories = theSeedTransformer->seedTransform(seed);
-    if(!seedTrajectories.empty()) {
-      TrajectoryMeasurement lastTM(seedTrajectories.front().lastMeasurement());
-      lastTSOS = lastTM.updatedState();
-      lastDetId = lastTM.recHit()->geographicalId();
-    }
-  }
-  
-  if(!doSeedRefit || seedTrajectories.empty()) {
-    lastTSOS = theSeedTransformer->seedTransientState(seed);
-    lastDetId = seed.startingState().detId();
-  }
-
-  LogTrace(metname) << "Trajectory State on Surface before the extrapolation"<<endl;
-  LogTrace(metname) << debug.dumpTSOS(lastTSOS);
-  
-  // Segment layer
-  LogTrace(metname) << "The RecSegment relies on: "<<endl;
-  LogTrace(metname) << debug.dumpMuonId(lastDetId);
-
-  DetLayerWithState inputFromSeed = propagateTheSeedTSOS(lastTSOS, lastDetId);
-
-  // refine the FTS given by the seed
-
-  // the trajectory is filled in the refitter::refit
-  filter()->refit(inputFromSeed.second,inputFromSeed.first,trajectoryFW);
-
-  // "0th order" check...
-  if( trajectoryFW.empty() ) {
-    LogTrace(metname) << "Forward trajectory EMPTY! No trajectory will be loaded!" << endl;
-    return trajectoryContainer;
-  }
-
-  // Get the last TSOS
-  //  TrajectoryStateOnSurface tsosAfterRefit = filter()->lastUpdatedTSOS();     // this is the last UPDATED TSOS
-  TrajectoryStateOnSurface tsosAfterRefit = filter()->lastCompatibleTSOS();     // this is the last COMPATIBLE TSOS
-
-  LogTrace(metname) << "StandAloneMuonTrajectoryBuilder filter output " << endl;
-  LogTrace(metname) << debug.dumpTSOS(tsosAfterRefit);
-  
-
-  /*
-  // -- 1st attempt
-  if( filter()->isCompatibilitySatisfied() ) {
-    if( filter()->layers().size() )   //  OR   if( filter()->goodState() ) ???  Maybe when only RPC hits are used...
-      LogTrace(metname) << debug.dumpLayer( filter()->lastDetLayer() );
-    else {
-      LogTrace(metname) << "Compatibility satisfied, but all RecHits are invalid! A trajectory with only invalid hits will be loaded!" << endl;
-      trajectoryContainer.push_back(new Trajectory(trajectoryFW));
-      return trajectoryContainer;
-    }
-  }
-  else {
-    LogTrace(metname) << "Compatibility NOT satisfied after Forward filter! No trajectory will be loaded!" << endl;
-    LogTrace(metname) << "Total chambers: " << filter()->getTotalCompatibleChambers() << "; DT: " 
-		      << filter()->getDTCompatibleChambers() << "; CSC: " << filter()->getCSCCompatibleChambers() << endl;
-    return trajectoryContainer; 
-  }
-  // -- end 1st attempt
-  */
-
-  // -- 2nd attempt
-  if( filter()->goodState() ) {
-    LogTrace(metname) << debug.dumpLayer( filter()->lastDetLayer() );
-  }
-  else if( filter()->isCompatibilitySatisfied() ) {
-    int foundValidRh = trajectoryFW.foundHits();  // number of valid hits
-    LogTrace(metname) << "Compatibility satisfied after Forward filter, but too few valid RecHits ("
-		      << foundValidRh << ")." << endl
-		      << "A trajectory with only invalid RecHits will be loaded!" << endl;
-    if(!foundValidRh) {
-      trajectoryContainer.push_back(new Trajectory(trajectoryFW));
-      return trajectoryContainer;
-    }
-    Trajectory defaultTraj(seed,fwDirection);
-    filter()->createDefaultTrajectory(trajectoryFW, defaultTraj);
-    trajectoryContainer.push_back(new Trajectory(defaultTraj));
-    return trajectoryContainer;
-  }
-  else {
-    LogTrace(metname) << "Compatibility NOT satisfied after Forward filter! No trajectory will be loaded!" << endl;
-    LogTrace(metname) << "Total compatible chambers: " << filter()->getTotalCompatibleChambers() << ";  DT: " 
-		      << filter()->getDTCompatibleChambers() << ";  CSC: " << filter()->getCSCCompatibleChambers() 
-		      << ";  RPC: " << filter()->getRPCCompatibleChambers()
-		      << ";  GEM: " << filter()->getGEMCompatibleChambers()
-		      << ";  ME0: " << filter()->getME0CompatibleChambers() << endl;
-    return trajectoryContainer; 
-  }
-  // -- end 2nd attempt
-
-  LogTrace(metname) << "Number of DT/CSC/RPC/GEM/ME0 chamber used (fw): " 
-       << filter()->getDTChamberUsed() << "/"
-       << filter()->getCSCChamberUsed() << "/"
-       << filter()->getRPCChamberUsed() << "/"
-       << filter()->getGEMChamberUsed() << "/"
-       << filter()->getME0ChamberUsed() <<endl;
-  LogTrace(metname) << "Momentum: " <<tsosAfterRefit.freeState()->momentum();
-  
-
-  if(!doBackwardFilter) { 
-    LogTrace(metname) << "Only forward refit requested. No backward refit will be performed!"<<endl;
-    
-    // ***** Refit of fwd step *****
-    //    if (doRefit && !trajectoryFW.empty() && filter()->goodState()){    // CHECK!!! Can trajectoryFW really be empty at this point??? And goodState...?
-    if(doRefit) {
-      pair<bool,Trajectory> refitResult = refitter()->refit(trajectoryFW);
-      if(refitResult.first) {
-	trajectoryContainer.push_back(new Trajectory(refitResult.second));
-	LogTrace(metname) << "StandAloneMuonTrajectoryBuilder refit output " << endl ;
-	LogTrace(metname) << debug.dumpTSOS(refitResult.second.lastMeasurement().updatedState());
-      }
-      else
-	trajectoryContainer.push_back(new Trajectory(trajectoryFW));
-    }
-    else
-      trajectoryContainer.push_back(new Trajectory(trajectoryFW));
-
-    LogTrace(metname) << "Trajectory saved" << endl;
-    return trajectoryContainer;
-  }
-
-
-  // ***** Backward filtering *****
-  
-  TrajectorySeed seedForBW;
-
-  if(theBWSeedType == "noSeed") {
-    TrajectorySeed seedVoid;
-    seedForBW = seedVoid;
-  }
-  else if(theBWSeedType == "fromFWFit") {
-
-    
-    
-    PTrajectoryStateOnDet seedTSOS =
-      trajectoryStateTransform::persistentState( tsosAfterRefit, trajectoryFW.lastMeasurement().recHit()->geographicalId().rawId());
-    
-    edm::OwnVector<TrackingRecHit> recHitsContainer;
-    PropagationDirection seedDirection = (theSeedPosition == recoMuon::in) ?  oppositeToMomentum : alongMomentum;
-    TrajectorySeed fwFit(seedTSOS,recHitsContainer,seedDirection);
-
-    seedForBW = fwFit;
-  }
-  else if(theBWSeedType == "fromGenerator") {
-    seedForBW = seed;
-  }
-  else
-    LogWarning(metname) << "Wrong seed type for the backward filter!";
-
-  PropagationDirection bwDirection = (theSeedPosition == recoMuon::in) ?  oppositeToMomentum : alongMomentum;
-  Trajectory trajectoryBW(seedForBW,bwDirection);
-
-  // FIXME! under check!
-  bwfilter()->refit(tsosAfterRefit,filter()->lastDetLayer(),trajectoryBW);
-
-  // Get the last TSOS
-  TrajectoryStateOnSurface tsosAfterBWRefit = bwfilter()->lastUpdatedTSOS();
-
-  LogTrace(metname) << "StandAloneMuonTrajectoryBuilder BW filter output " << endl ;
-  LogTrace(metname) << debug.dumpTSOS(tsosAfterBWRefit);
-
-  LogTrace(metname) 
-    << "Number of RecHits: " << trajectoryBW.foundHits() << "\n"
-    << "Number of DT/CSC/RPC/GEM/ME0 chamber used (bw): " 
-    << bwfilter()->getDTChamberUsed() << "/"
-    << bwfilter()->getCSCChamberUsed() << "/" 
-    << bwfilter()->getRPCChamberUsed() << "/"
-    << bwfilter()->getGEMChamberUsed() << "/"
-    << bwfilter()->getME0ChamberUsed();
-  
-  // -- The trajectory is "good" if there are at least 2 chambers used in total and at
-  //    least 1 is "tracking" (DT or CSC)
-  // -- The trajectory satisfies the "compatibility" requirements if there are at least 
-  //    2 compatible chambers (not necessarily used!) in total and at
-  //    least 1 is "tracking" (DT or CSC)
-  // 1st attempt
-  /*
-  if (bwfilter()->isCompatibilitySatisfied()) {
-    
-    if (doRefit && !trajectoryBW.empty() && bwfilter()->goodState()){
-      pair<bool,Trajectory> refitResult = refitter()->refit(trajectoryBW);
-      if (refitResult.first){
-     	trajectoryContainer.push_back(new Trajectory(refitResult.second));
-	LogTrace(metname) << "StandAloneMuonTrajectoryBuilder Refit output " << endl;
-	LogTrace(metname) << debug.dumpTSOS(refitResult.second.lastMeasurement().updatedState());
-      }
-      else
-	trajectoryContainer.push_back(new Trajectory(trajectoryBW));
-    }
-    else
-      trajectoryContainer.push_back(new Trajectory(trajectoryBW));
-    
-    LogTrace(metname)<< "Trajectory saved" << endl;
-    
-  }
-  //if the trajectory is not saved, but at least two chamber are used in the
-  //forward filtering, try to build a new trajectory starting from the old
-  //trajectory w/o the latest measurement and a looser chi2 cut
-  else if ( filter()->getTotalChamberUsed() >= 2 ) {
-    LogTrace(metname)<< "Trajectory NOT saved. Second Attempt." << endl;
-    // FIXME:
-    // a better choice could be: identify the poorest one, exclude it, redo
-    // the fw and bw filtering. Or maybe redo only the bw without the excluded
-    // measure. As first step I will port the ORCA algo, then I will move to the
-    // above pattern.
-    
-  }
-
-  else {
-    LogTrace(metname) << "Compatibility NOT satisfied after Backward filter!" << endl;
-    LogTrace(metname) << "The result of Forward filter will be loaded!" << endl;
-
-    trajectoryContainer.push_back(new Trajectory(trajectoryFW));
-  }
-  */
-  // end 1st attempt
-
-  // 2nd attempt
-  if( bwfilter()->goodState() ) {
-    LogTrace(metname) << debug.dumpLayer( bwfilter()->lastDetLayer() );
-  }
-  else if( bwfilter()->isCompatibilitySatisfied() ) {
-    LogTrace(metname) << "Compatibility satisfied after Backward filter, but too few valid RecHits ("
-		      << trajectoryBW.foundHits() << ")." << endl
-		      << "The (good) result of FW filter will be loaded!" << endl;
-    trajectoryContainer.push_back(new Trajectory(trajectoryFW));
-    return trajectoryContainer;
-  }
-  else {
-    LogTrace(metname) << "Compatibility NOT satisfied after Backward filter!" << endl 
-                      << "The Forward trajectory will be invalidated and then loaded!" << endl;
-    Trajectory defaultTraj(seed,fwDirection);
-    filter()->createDefaultTrajectory(trajectoryFW, defaultTraj);
-    trajectoryContainer.push_back(new Trajectory(defaultTraj));
-    return trajectoryContainer;
-  }
-  // end 2nd attempt
-
-  if(doRefit) {
-    pair<bool,Trajectory> refitResult = refitter()->refit(trajectoryBW);
-    if(refitResult.first) {
-      trajectoryContainer.push_back(new Trajectory(refitResult.second));
-      LogTrace(metname) << "StandAloneMuonTrajectoryBuilder Refit output " << endl;
-      LogTrace(metname) << debug.dumpTSOS(refitResult.second.lastMeasurement().updatedState());
-    }
-    else
-      trajectoryContainer.push_back(new Trajectory(trajectoryBW));
-  }
-  else
-    trajectoryContainer.push_back(new Trajectory(trajectoryBW));
-    
-  LogTrace(metname) << "Trajectory saved" << endl;
-    
-  return trajectoryContainer;
-}
-
-
-StandAloneMuonTrajectoryBuilder::DetLayerWithState
-StandAloneMuonTrajectoryBuilder::propagateTheSeedTSOS(TrajectoryStateOnSurface& aTSOS, DetId& aDetId) {
-
-  const std::string metname = "Muon|RecoMuon|StandAloneMuonTrajectoryBuilder";
-  MuonPatternRecoDumper debug;
-
-  DetId seedDetId(aDetId);
-  //  const GeomDet* gdet = theService->trackingGeometry()->idToDet( seedDetId );
-
-  TrajectoryStateOnSurface initialState(aTSOS);
-
-  LogTrace(metname)<<"Seed's Pt: "<<initialState.freeState()->momentum().perp()<<endl;
-
-  LogTrace(metname)<< "Seed's id: "<< endl ;
-  LogTrace(metname) << debug.dumpMuonId(seedDetId);
-  
-  // Get the layer on which the seed relies
-  const DetLayer *initialLayer = theService->detLayerGeometry()->idToLayer( seedDetId );
-
-  LogTrace(metname)<< "Seed's detLayer: "<< endl ;
-  LogTrace(metname) << debug.dumpLayer(initialLayer);
-
-  LogTrace(metname)<< "TrajectoryStateOnSurface before propagation:" << endl;
-  LogTrace(metname) << debug.dumpTSOS(initialState);
-
-
-  PropagationDirection detLayerOrder = (theSeedPosition == recoMuon::in) ? oppositeToMomentum : alongMomentum;
-
-  // ask for compatible layers
-  vector<const DetLayer*> detLayers;
-
-  if(theNavigationType == "Standard")
-    detLayers = initialLayer->compatibleLayers( *initialState.freeState(),detLayerOrder); 
-  else if (theNavigationType == "Direct"){
-    DirectMuonNavigation navigation( &*theService->detLayerGeometry() );
-    detLayers = navigation.compatibleLayers( *initialState.freeState(),detLayerOrder);
-  }
-  else
-    edm::LogError(metname) << "No Properly Navigation Selected!!"<<endl;
-
- 
-  LogTrace(metname) << "There are "<< detLayers.size() <<" compatible layers"<<endl;
-  
-  DetLayerWithState result = DetLayerWithState(initialLayer,initialState);
-
-  if(detLayers.size()){
-
-    LogTrace(metname) << "Compatible layers:"<<endl;
-    for( vector<const DetLayer*>::const_iterator layer = detLayers.begin(); 
-	 layer != detLayers.end(); layer++){
-      LogTrace(metname) << debug.dumpMuonId((*layer)->basicComponents().front()->geographicalId());
-      LogTrace(metname) << debug.dumpLayer(*layer);
-    }
-
-    const DetLayer* finalLayer = detLayers.back();
-
-    if(theSeedPosition == recoMuon::in) LogTrace(metname) << "Most internal one:"<<endl;
-    else LogTrace(metname) << "Most external one:"<<endl;
-    
-    LogTrace(metname) << debug.dumpLayer(finalLayer);
-    
-    const TrajectoryStateOnSurface propagatedState = 
-      theService->propagator(theSeedPropagatorName)->propagate(initialState,
-							       finalLayer->surface());
-
-    if(propagatedState.isValid()){
-      result = DetLayerWithState(finalLayer,propagatedState);
-      
-      LogTrace(metname) << "Trajectory State on Surface after the extrapolation"<<endl;
-      LogTrace(metname) << debug.dumpTSOS(propagatedState);
-      LogTrace(metname) << debug.dumpLayer(finalLayer);
-    }
-    else 
-      LogTrace(metname)<< "Extrapolation failed. Keep the original seed state" <<endl;
-  }
-  else
-    LogTrace(metname)<< "No compatible layers. Keep the original seed state" <<endl;
-  
-  return result;
-}
-
-
diff --git a/SLHCUpgradeSimulations/Configuration/python/me0Customs.py~ b/SLHCUpgradeSimulations/Configuration/python/me0Customs.py~
deleted file mode 100644
index 457cbf1..0000000
--- a/SLHCUpgradeSimulations/Configuration/python/me0Customs.py~
+++ /dev/null
@@ -1,120 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-def customise(process):
-    if hasattr(process,'digitisation_step'):
-        process=customise_Digi(process)
-    if hasattr(process,'L1simulation_step'):
-       process=customise_L1Emulator(process)
-    if hasattr(process,'DigiToRaw'):
-        process=customise_DigiToRaw(process)
-    if hasattr(process,'RawToDigi'):
-        process=customise_RawToDigi(process)
-    if hasattr(process,'reconstruction'):
-        process=customise_RecoFull(process)
-    if hasattr(process,'reconstruction'):
-        process=customise_Reco(process)
-    if hasattr(process,'famosWithEverything'):
-        process=customise_RecoFast(process)
-    if hasattr(process,'dqmoffline_step'):
-        process=customise_DQM(process)
-    if hasattr(process,'dqmHarvesting'):
-        process=customise_harvesting(process)
-    if hasattr(process,'validation_step'):
-        process=customise_Validation(process)
-    return process
-
-def customise_Digi(process):
-    process.RandomNumberGeneratorService.simMuonME0Digis = cms.PSet(
-        initialSeed = cms.untracked.uint32(1234567),
-        engineName = cms.untracked.string('HepJamesRandom')
-    )
-    process.mix.mixObjects.mixSH.crossingFrames.append('MuonME0Hits')
-    process.mix.mixObjects.mixSH.input.append(cms.InputTag("g4SimHits","MuonME0Hits"))
-    process.mix.mixObjects.mixSH.subdets.append('MuonME0Hits')
-    process.load('SimMuon.GEMDigitizer.muonME0DigisPreReco_cfi')
-    process.muonDigi += process.simMuonME0Digis
-    process=outputCustoms(process)
-    return process
-
-def customise_L1Emulator(process):
-    return process
-
-def customise_DigiToRaw(process):
-    return process
-
-def customise_RawToDigi(process):
-    return process
-
-def customise_LocalReco(process):
-    process.load('RecoLocalMuon.GEMRecHit.me0LocalReco_cff')
-    process.muonlocalreco += process.me0LocalReco
-    process=outputCustoms(process)
-    return process
-
-def customise_GlobalRecoInclude(process):
-    process.load("TrackPropagation.SteppingHelixPropagator.SteppingHelixPropagatorAlong_cfi")
-    process.load("TrackPropagation.SteppingHelixPropagator.SteppingHelixPropagatorOpposite_cfi")
-    process.load("TrackPropagation.SteppingHelixPropagator.SteppingHelixPropagatorAny_cfi")
-    return process
-
-def customise_GlobalRecoFast(process):
-    customise_GlobalRecoInclude(process)
-    process.load('RecoMuon.MuonIdentification.me0MuonReco_cff')
-    process.reconstructionWithFamos += process.me0MuonReco
-    return process
-
-def customise_GlobalRecoFull(process):
-    customise_GlobalRecoInclude(process)
-    process.load('RecoMuon.MuonIdentification.me0MuonReco_cff')
-    process.muonGlobalReco += process.me0MuonReco
-    return process
-
-def customise_RecoFast(process):
-    process=customise_LocalReco(process)
-    process=customise_GlobalRecoFast(process)
-    process=outputCustoms(process)
-    return process
-
-def customise_RecoFull(process):
-    process=customise_LocalReco(process)
-    process=customise_GlobalRecoFull(process)
-    process=outputCustoms(process)
-    return process
-
-
-def customise_Reco(process):
-    #process.load('RecoLocalMuon.GEMRecHit.gemRecHits_cfi')
-    process.load('RecoLocalMuon.GEMRecHit.gemRecHits_cfi')
-    process.muonlocalreco += process.gemRecHits
-    process.standAloneMuons.STATrajBuilderParameters.EnableGEMMeasurement = cms.bool(True)
-    process.standAloneMuons.STATrajBuilderParameters.BWFilterParameters.EnableGEMMeasurement = cms.bool(True)
-    process.refittedStandAloneMuons.STATrajBuilderParameters.EnableGEMMeasurement = cms.bool(True)
-    process.refittedStandAloneMuons.STATrajBuilderParameters.BWFilterParameters.EnableGEMMeasurement = cms.bool(True)
-    process=outputCustoms(process)
-    return process
-
-def customise_Validation(process):
-    process.load('Validation.Configuration.gemSimValid_cff')
-    process.genvalid_all += process.me0SimValid
-    return process
-
-def customise_DQM(process):
-    return process
-
-def customise_harvesting(process):
-    return process
-
-def outputCustoms(process):
-    alist=['AODSIM','RECOSIM','FEVTSIM','FEVTDEBUG','FEVTDEBUGHLT','RECODEBUG','RAWRECOSIMHLT','RAWRECODEBUGHLT']
-    for a in alist:
-        b=a+'output'
-        if hasattr(process,b):
-            getattr(process,b).outputCommands.append('keep *_simMuonME0Digis_*_*')
-            getattr(process,b).outputCommands.append('keep *_me0RecHits_*_*')
-            getattr(process,b).outputCommands.append('keep *_me0Segments_*_*')
-            getattr(process,b).outputCommands.append('keep *_me0SegmentProducer_*_*')
-            getattr(process,b).outputCommands.append('drop *_me0SegmentMatcher_*_*')
-            getattr(process,b).outputCommands.append('drop *_me0MuonConverter_*_*')
-            getattr(process,b).outputCommands.append('keep *_me0SegmentMatching_*_*')
-            getattr(process,b).outputCommands.append('keep *_me0MuonConverting_*_*')
-    return process
diff --git a/TrackingTools/TrackFitters/src/KFTrajectoryFitter.cc~ b/TrackingTools/TrackFitters/src/KFTrajectoryFitter.cc~
deleted file mode 100644
index 68f969e..0000000
--- a/TrackingTools/TrackFitters/src/KFTrajectoryFitter.cc~
+++ /dev/null
@@ -1,225 +0,0 @@
-#include "TrackingTools/TrackFitters/interface/KFTrajectoryFitter.h"
-#include "TrackingTools/TrackFitters/interface/TrajectoryStateWithArbitraryError.h"
-#include "TrackingTools/TransientTrackingRecHit/interface/TransientTrackingRecHit.h"
-#include "FWCore/Utilities/interface/Exception.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "DataFormats/TrackerCommon/interface/TrackerTopology.h"
-#include "Geometry/Records/interface/IdealGeometryRecord.h"
-#include "DataFormats/MuonDetId/interface/CSCDetId.h"
-#include "DataFormats/MuonDetId/interface/DTWireId.h"
-#include "DataFormats/MuonDetId/interface/RPCDetId.h"
-#include "DataFormats/MuonDetId/interface/MuonSubdetId.h"
-#include "FWCore/Utilities/interface/isFinite.h"
-
-
-const DetLayerGeometry KFTrajectoryFitter::dummyGeometry;
-
-Trajectory KFTrajectoryFitter::fitOne(const Trajectory& aTraj, fitType type) const {
-
-  if(aTraj.empty()) return Trajectory();
- 
-  TM firstTM = aTraj.firstMeasurement();
-  TSOS firstTsos = TrajectoryStateWithArbitraryError()(firstTM.updatedState());
-  
-  return fitOne(aTraj.seed(), aTraj.recHits(), firstTsos,type);
-}
-
-Trajectory KFTrajectoryFitter::fitOne(const TrajectorySeed&,
-				      const RecHitContainer&, fitType) const{
-
-  throw cms::Exception("TrackFitters", 
-		       "KFTrajectoryFitter::fit(TrajectorySeed, <TransientTrackingRecHit>) not implemented"); 
-
-  return Trajectory();
-}
-
-Trajectory KFTrajectoryFitter::fitOne(const TrajectorySeed& aSeed,
-				      const RecHitContainer& hits,
-				      const TSOS& firstPredTsos,fitType) const 
-{
-  if(hits.empty()) return Trajectory();
-
-
-  if unlikely(aSeed.direction() == anyDirection) 
-    throw cms::Exception("KFTrajectoryFitter","TrajectorySeed::direction() requested but not set");
-  
-  SetPropagationDirection setDir(*thePropagator,aSeed.direction());
-
-#ifdef EDM_ML_DEBUG
-  LogDebug("TrackFitters")
-    <<" +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
-    <<" KFTrajectoryFitter::fit starting with " << hits.size() <<" HITS";
-  
-  for (unsigned int j=0;j<hits.size();j++) { 
-    if (hits[j]->det()) 
-      LogTrace("TrackFitters") << "hit #:" << j+1 << " rawId=" << hits[j]->det()->geographicalId().rawId() 
-			       << " validity=" << hits[j]->isValid();
-    else
-      LogTrace("TrackFitters") << "hit #:" << j+1 << " Hit with no Det information";
-  }
-  LogTrace("TrackFitters") << " INITIAL STATE "<< firstPredTsos;
-#endif
-
-  Trajectory ret(aSeed, thePropagator->propagationDirection());
-  Trajectory & myTraj = ret;
-  myTraj.reserve(hits.size());
-
-  TSOS predTsos(firstPredTsos);
-  TSOS currTsos;
-
-  int hitcounter = 1;
-  for(RecHitContainer::const_iterator ihit = hits.begin(); ihit != hits.end(); ++ihit, ++hitcounter) {
-
-    const TransientTrackingRecHit & hit = (**ihit);
-    
-    if unlikely( (!hit.isValid()) && hit.surface() == nullptr) {
-      LogDebug("TrackFitters")<< " Error: invalid hit with no GeomDet attached .... skipping";
-      continue;
-    }
-
-#ifdef EDM_ML_DEBUG
-    if (hit.isValid()) {
-      LogTrace("TrackFitters")
-	<< " ----------------- HIT #" << hitcounter << " (VALID)-----------------------\n"
-	<< "  HIT IS AT R   " << hit.globalPosition().perp() << "\n"
-	<< "  HIT IS AT Z   " << hit.globalPosition().z() << "\n"
-	<< "  HIT IS AT Phi " << hit.globalPosition().phi() << "\n"
-	<< "  HIT IS AT Loc " << hit.localPosition() << "\n"
-	<< "  WITH LocError " << hit.localPositionError() << "\n"
-	<< "  HIT IS AT Glo " << hit.globalPosition() << "\n"
-	<< "SURFACE POSITION" << "\n"
-	<< hit.surface()->position()<<"\n"
-	<< "SURFACE ROTATION" << "\n"
-	<< hit.surface()->rotation();
-      
-      DetId hitId = hit.geographicalId();
-
-      LogTrace("TrackFitters") << " hit det=" << hitId.rawId();
-      
-      // if(hitId.det() == DetId::Tracker) {
-      // 	if (hitId.subdetId() == StripSubdetector::TIB )  
-      // 	  LogTrace("TrackFitters") << " I am TIB " << tTopo->tibLayer(hitId);
-      // 	else if (hitId.subdetId() == StripSubdetector::TOB ) 
-      // 	  LogTrace("TrackFitters") << " I am TOB " << tTopo->tobLayer(hitId);
-      // 	else if (hitId.subdetId() == StripSubdetector::TEC ) 
-      // 	  LogTrace("TrackFitters") << " I am TEC " << tTopo->tecWheel(hitId);
-      // 	else if (hitId.subdetId() == StripSubdetector::TID ) 
-      // 	  LogTrace("TrackFitters") << " I am TID " << tTopo->tidWheel(hitId);
-      // 	else if (hitId.subdetId() == StripSubdetector::TID ) 
-      // 	  LogTrace("TrackFitters") << " I am TID " << tTopo->tidWheel(hitId);
-      // 	else if (hitId.subdetId() == (int) PixelSubdetector::PixelBarrel ) 
-      // 	  LogTrace("TrackFitters") << " I am PixBar " << tTopo->pxbLayer(hitId);
-      // 	else if (hitId.subdetId() == (int) PixelSubdetector::PixelEndcap )
-      // 	  LogTrace("TrackFitters") << " I am PixFwd " << tTopo->pxfDisk(hitId);
-      // 	else 
-      // 	  LogTrace("TrackFitters") << " UNKNOWN TRACKER HIT TYPE ";
-      // }
-      if(hitId.det() == DetId::Muon) {
-	if(hitId.subdetId() == MuonSubdetId::DT)
-	  LogTrace("TrackFitters") << " I am DT " << DTWireId(hitId);
-	else if (hitId.subdetId() == MuonSubdetId::CSC )
-	  LogTrace("TrackFitters") << " I am CSC " << CSCDetId(hitId);
-	else if (hitId.subdetId() == MuonSubdetId::RPC )
-	  LogTrace("TrackFitters") << " I am RPC " << RPCDetId(hitId);
-	else if (hitId.subdetId() == MuonSubdetId::GEM )
-	  LogTrace("TrackFitters") << " I am GEM " << GEMDetId(hitId);
-
-	else if (hitId.subdetId() == MuonSubdetId::ME0 )
-	  LogTrace("TrackFitters") << " I am ME0 " << ME0DetId(hitId);
-	else 
-	  LogTrace("TrackFitters") << " UNKNOWN MUON HIT TYPE ";
-      }
-      else
-	LogTrace("TrackFitters") << " UNKNOWN HIT TYPE ";
-      
-    } else {
-      LogTrace("TrackFitters")
-	<< " ----------------- INVALID HIT #" << hitcounter << " -----------------------";      
-    }
-#endif    
-
-    if ( hitcounter != 1) //no propagation needed for the first hit
-      predTsos = thePropagator->propagate( currTsos, *(hit.surface()) );
-    
-
-    if unlikely(!predTsos.isValid()) {
-      LogDebug("TrackFitters") 
-	<< "SOMETHING WRONG !" << "\n"
-	<< "KFTrajectoryFitter: predicted tsos not valid!\n" 
-	<< "current TSOS: " << currTsos << "\n";
-
-      if(hit.surface())	LogTrace("TrackFitters") << "next Surface: " << hit.surface()->position() << "\n";
-      
-      if( myTraj.foundHits() >= minHits_ ) {
-	LogDebug("TrackFitters") << " breaking trajectory" << "\n";
-	break;      
-      } else {        
-	LogDebug("TrackFitters") << " killing trajectory" << "\n";       
-	return Trajectory();
-      }
-    }
-    
-    if likely(hit.isValid()) {
-	//update
-	LogTrace("TrackFitters") << "THE HIT IS VALID: updating hit with predTsos";
-	TransientTrackingRecHit::RecHitPointer preciseHit = hit.clone(predTsos);
-	
-	if unlikely(!preciseHit->isValid()){
-	    LogTrace("TrackFitters") << "THE Precise HIT IS NOT VALID: using currTsos = predTsos" << "\n";
-	    currTsos = predTsos;
-	    myTraj.push(TM(predTsos, *ihit,0,theGeometry->idToLayer((*ihit)->geographicalId()) ));
-	    
-	  }else{
-	  LogTrace("TrackFitters") << "THE Precise HIT IS VALID: updating currTsos" << "\n";
-	  currTsos = updator()->update(predTsos, *preciseHit);
-	  //check for valid hits with no det (refitter with constraints)
-	  bool badState = (!currTsos.isValid())
-          || (hit.geographicalId().det() == DetId::Tracker
-              &&
-              (std::abs(currTsos.localParameters().qbp())>100
-               || std::abs(currTsos.localParameters().position().y()) > 1000
-               || std::abs(currTsos.localParameters().position().x()) > 1000
-               ) ) || edm::isNotFinite(currTsos.localParameters().qbp());
-	  if unlikely(badState){
-	    if (!currTsos.isValid()) edm::LogError("FailedUpdate")
-	     <<"updating with the hit failed. Not updating the trajectory with the hit";
-	    else if (edm::isNotFinite(currTsos.localParameters().qbp())) edm::LogError("TrajectoryNaN")<<"Trajectory has NaN";
-	    else LogTrace("FailedUpdate")<<"updated state is valid but pretty bad, skipping. currTsos "
-	    				 <<currTsos<<"\n predTsos "<<predTsos;
-	    myTraj.push(TM(predTsos, *ihit,0,theGeometry->idToLayer((*ihit)->geographicalId())  ));
-	    //There is a no-fail policy here. So, it's time to give up
-	    //Keep the traj with invalid TSOS so that it's clear what happened
-	    if( myTraj.foundHits() >= minHits_ ) {
-	      LogDebug("TrackFitters") << " breaking trajectory" << "\n";
-	      break;      
-	    } else {        
-	      LogDebug("TrackFitters") << " killing trajectory" << "\n";       
-	      return Trajectory();
-	    }
-	  } else{
-	    if (preciseHit->det()) myTraj.push(TM(predTsos, currTsos, preciseHit,
-						  estimator()->estimate(predTsos, *preciseHit).second,
-						  theGeometry->idToLayer(preciseHit->geographicalId())  ));
-	    else myTraj.push(TM(predTsos, currTsos, preciseHit,
-				estimator()->estimate(predTsos, *preciseHit).second));
-	  }
-	}
-      } else {
-      //no update
-      LogDebug("TrackFitters") << "THE HIT IS NOT VALID: using currTsos" << "\n";
-      currTsos = predTsos;
-      myTraj.push(TM(predTsos, *ihit,0,theGeometry->idToLayer((*ihit)->geographicalId())  ));
-    }
-    
-    LogTrace("TrackFitters")
-      << "predTsos !" << "\n"
-      << predTsos << "\n"
-      <<"currTsos !" << "\n"
-      << currTsos;
-  }  
-  
-  LogDebug("TrackFitters") << "Found 1 trajectory with " << myTraj.foundHits() << " valid hits\n";
-  
-  return ret;
-}
-
diff --git a/TrackingTools/TrackFitters/src/KFTrajectorySmoother.cc~ b/TrackingTools/TrackFitters/src/KFTrajectorySmoother.cc~
deleted file mode 100644
index a0768c0..0000000
--- a/TrackingTools/TrackFitters/src/KFTrajectorySmoother.cc~
+++ /dev/null
@@ -1,267 +0,0 @@
-#include "TrackingTools/TrackFitters/interface/KFTrajectorySmoother.h"
-#include "TrackingTools/TransientTrackingRecHit/interface/TransientTrackingRecHit.h"
-#include "TrackingTools/TrackFitters/interface/TrajectoryStateWithArbitraryError.h"
-#include "TrackingTools/TrackFitters/interface/TrajectoryStateCombiner.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-#ifdef EDM_ML_DEBUG
-#include "DataFormats/TrackerCommon/interface/TrackerTopology.h"
-#include "Geometry/Records/interface/IdealGeometryRecord.h"
-#include "DataFormats/MuonDetId/interface/CSCDetId.h"
-#include "DataFormats/MuonDetId/interface/DTWireId.h"
-#include "DataFormats/MuonDetId/interface/RPCDetId.h"
-#include "DataFormats/MuonDetId/interface/MuonSubdetId.h"
-#endif
-
-#include "FWCore/Utilities/interface/GCC11Compatibility.h"
-
-
-KFTrajectorySmoother::~KFTrajectorySmoother() {
-
-  delete thePropagator;
-  delete theUpdator;
-  delete theEstimator;
-
-}
-
-Trajectory
-KFTrajectorySmoother::trajectory(const Trajectory& aTraj) const {
-
-  if(aTraj.empty()) return Trajectory();
-
-  if (  aTraj.direction() == alongMomentum) {
-    thePropagator->setPropagationDirection(oppositeToMomentum);
-  } else {
-    thePropagator->setPropagationDirection(alongMomentum);
-  }
-  
-  const std::vector<TM> & avtm = aTraj.measurements();
-  
-  Trajectory ret(aTraj.seed(), thePropagator->propagationDirection());
-  Trajectory & myTraj = ret;
-  myTraj.reserve(avtm.size());
-  
-  
-  
-#ifdef EDM_ML_DEBUG
-  LogDebug("TrackFitters") << "KFTrajectorySmoother::trajectories starting with " << avtm.size() << " HITS\n";
-  for (unsigned int j=0;j<avtm.size();j++) { 
-    if (avtm[j].recHit()->det()) 
-      LogTrace("TrackFitters") << "hit #:" << j+1 << " rawId=" << avtm[j].recHit()->det()->geographicalId().rawId() 
-			       << " validity=" << avtm[j].recHit()->isValid();
-    else
-      LogTrace("TrackFitters") << "hit #:" << j+1 << " Hit with no Det information";
-  }
-#endif // EDM_ML_DEBUG
-  
-  
-  TSOS predTsos = avtm.back().forwardPredictedState();
-  predTsos.rescaleError(theErrorRescaling);
-  TSOS currTsos;
-  
-  TrajectoryStateCombiner combiner;
-  
-  unsigned int hitcounter = avtm.size();
-  for(std::vector<TM>::const_reverse_iterator itm = avtm.rbegin(); itm != (avtm.rend()); ++itm,--hitcounter) {
-
-    TransientTrackingRecHit::ConstRecHitPointer hit = itm->recHit();
-
-    //check surface just for safety: should never be ==0 because they are skipped in the fitter 
-    if unlikely( hit->surface()==nullptr ) {
-	LogDebug("TrackFitters")<< " Error: invalid hit with no GeomDet attached .... skipping";
-	continue;
-      }
-
-    if (hitcounter != avtm.size())//no propagation needed for first smoothed (==last fitted) hit 
-      predTsos = thePropagator->propagate( currTsos, *(hit->surface()) );
-
-    if unlikely(!predTsos.isValid()) {
-	LogDebug("TrackFitters") << "KFTrajectorySmoother: predicted tsos not valid!";
-	if( myTraj.foundHits() >= minHits_ ) {
-	  LogDebug("TrackFitters") << " breaking trajectory" << "\n";
-	} else {        
-	  LogDebug("TrackFitters") << " killing trajectory" << "\n";      
-	  return Trajectory();
-	}
-	break;      
-      }
-
-    if(hit->isValid()) {
- 
-#ifdef EDM_ML_DEBUG
-      LogDebug("TrackFitters")
-	<< "----------------- HIT #" << hitcounter << " (VALID)-----------------------\n"
-	<< "HIT IS AT R   " << hit->globalPosition().perp() << "\n"
-	<< "HIT IS AT Z   " << hit->globalPosition().z() << "\n"
-	<< "HIT IS AT Phi " << hit->globalPosition().phi() << "\n"
-	<< "HIT IS AT Loc " << hit->localPosition() << "\n"
-	<< "WITH LocError " << hit->localPositionError() << "\n"
-	<< "HIT IS AT Glo " << hit->globalPosition() << "\n"
-	<< "SURFACE POSITION: " << hit->surface()->position() << "\n"
-	<< "SURFACE ROTATION: " << hit->surface()->rotation() << "\n"
-	<< "hit geographicalId=" << hit->geographicalId().rawId();
-      
-      DetId hitId = hit->geographicalId();
-      
-      if(hitId.det() == DetId::Tracker) {
-	if (hitId.subdetId() == StripSubdetector::TIB )  
-	  LogTrace("TrackFitters") << " I am TIB " << tTopo->tibLayer(hitId);
-	else if (hitId.subdetId() == StripSubdetector::TOB ) 
-	  LogTrace("TrackFitters") << " I am TOB " << tTopo->tobLayer(hitId);
-	else if (hitId.subdetId() == StripSubdetector::TEC ) 
-	  LogTrace("TrackFitters") << " I am TEC " << tTopo->tecWheel(hitId);
-	else if (hitId.subdetId() == StripSubdetector::TID ) 
-	  LogTrace("TrackFitters") << " I am TID " << tTopo->tidWheel(hitId);
-	else if (hitId.subdetId() == StripSubdetector::TID ) 
-	  LogTrace("TrackFitters") << " I am TID " << tTopo->tidWheel(hitId);
-	else if (hitId.subdetId() == (int) PixelSubdetector::PixelBarrel ) 
-	  LogTrace("TrackFitters") << " I am PixBar " << tTopo->pxbLayer(hitId);
-	else if (hitId.subdetId() == (int) PixelSubdetector::PixelEndcap )
-	  LogTrace("TrackFitters") << " I am PixFwd " << tTopo->pxfDisk(hitId);
-	else 
-	  LogTrace("TrackFitters") << " UNKNOWN TRACKER HIT TYPE ";
-      }
-      else if(hitId.det() == DetId::Muon) {
-	if(hitId.subdetId() == MuonSubdetId::DT)
-	  LogTrace("TrackFitters") << " I am DT " << DTWireId(hitId);
-	else if (hitId.subdetId() == MuonSubdetId::CSC )
-	  LogTrace("TrackFitters") << " I am CSC " << CSCDetId(hitId);
-	else if (hitId.subdetId() == MuonSubdetId::RPC )
-	  LogTrace("TrackFitters") << " I am RPC " << RPCDetId(hitId);
-	else 
-	  LogTrace("TrackFitters") << " UNKNOWN MUON HIT TYPE ";
-      }
-      else
-	LogTrace("TrackFitters") << " UNKNOWN HIT TYPE ";
-#endif //EDM_ML_DEBUG
-      
-      
-      
-      TSOS combTsos,smooTsos;
-      
-      //3 different possibilities to calculate smoothed state:
-      //1: update combined predictions with hit
-      //2: combine fwd-prediction with bwd-filter
-      //3: combine bwd-prediction with fwd-filter
-
-      //combTsos is the predicted state with N-1 hits information. this means: 
-      //forward predicted state for first smoothed (last fitted) hit
-      //backward predicted state for last smoothed (first fitted) hit
-      //combination of forward and backward predictions for other hits
-      if (hitcounter == avtm.size()) combTsos = itm->forwardPredictedState();
-      else if (hitcounter == 1) combTsos = predTsos;
-      else combTsos = combiner(predTsos, itm->forwardPredictedState());
-      
-      if unlikely(!combTsos.isValid()) {
-	  LogDebug("TrackFitters") << 
-	    "KFTrajectorySmoother: combined tsos not valid!\n" <<
-	    "pred Tsos pos: " << predTsos.globalPosition() << "\n" <<
-	    "pred Tsos mom: " << predTsos.globalMomentum() << "\n" <<
-	    "TrackingRecHit: " << hit->surface()->toGlobal(hit->localPosition()) << "\n" ;
-	  if( myTraj.foundHits() >= minHits_ ) {
-	    LogDebug("TrackFitters") << " breaking trajectory" << "\n";
-	  } else {        
-	    LogDebug("TrackFitters") << " killing trajectory" << "\n";       
-	    return Trajectory();
-	  }
-	  break;      
-	}
-      
-      TransientTrackingRecHit::RecHitPointer preciseHit = hit->clone(combTsos);
-      
-      if unlikely(!preciseHit->isValid()){
-	  LogTrace("TrackFitters") << "THE Precise HIT IS NOT VALID: using currTsos = predTsos" << "\n";
-	  currTsos = predTsos;
-	  myTraj.push(TM(predTsos, hit, 0, theGeometry->idToLayer(hit->geographicalId()) ));
-	}else{
-	LogTrace("TrackFitters") << "THE Precise HIT IS VALID: updating currTsos" << "\n";
-	
-	//update backward predicted tsos with the hit
-	currTsos = updator()->update(predTsos, *preciseHit);
-        if unlikely(!currTsos.isValid()) {
-	    currTsos = predTsos;
-	    edm::LogWarning("KFSmoother_UpdateFailed") << 
-	      "Failed updating state with hit. Rolling back to non-updated state.\n" <<
-	      "State: "   << predTsos << 
-	      "Hit local pos:  " << hit->localPosition() << "\n" <<
-	      "Hit local err:  " << hit->localPositionError() << "\n" <<
-	      "Hit global pos: " << hit->globalPosition() << "\n" <<
-	      "Hit global err: " << hit->globalPositionError().matrix() << 
-	      "\n";
-	  }
-	
-	//smooTsos updates the N-1 hits prediction with the hit
-	if (hitcounter == avtm.size()) smooTsos = itm->updatedState();
-	else if (hitcounter == 1) smooTsos = currTsos;
-	else smooTsos = combiner(itm->forwardPredictedState(), currTsos); 
-	
-	if unlikely(!smooTsos.isValid()) {
-	    LogDebug("TrackFitters") << "KFTrajectorySmoother: smoothed tsos not valid!";
-	    if( myTraj.foundHits() >= minHits_ ) {
-	      LogDebug("TrackFitters") << " breaking trajectory" << "\n";
-	    } else {        
-	      LogDebug("TrackFitters") << " killing trajectory" << "\n";       
-	      return Trajectory();  
-	    }
-	    break;
-	  }
-	
-	double estimate;
-	if (hitcounter != avtm.size()) estimate = estimator()->estimate(combTsos, *preciseHit ).second;//correct?
-	else estimate = itm->estimate();
-	
-	LogTrace("TrackFitters")
-	  << "predTsos !" << "\n"
-	  << predTsos << "\n"
-	  << "currTsos !" << "\n"
-	  << currTsos << "\n"
-	  << "smooTsos !" << "\n"
-	  << smooTsos << "\n"
-	  << "smoothing estimate (with combTSOS)=" << estimate << "\n"
-	  << "filtering estimate=" << itm->estimate() << "\n";
-	
-	//check for valid hits with no det (refitter with constraints)
-	if (preciseHit->det()) myTraj.push(TM(itm->forwardPredictedState(),
-					      predTsos,
-					      smooTsos,
-					      preciseHit,
-					      estimate,
-					      theGeometry->idToLayer(preciseHit->geographicalId()) ),
-					   estimator()->estimate(predTsos,*preciseHit).second);
-	else myTraj.push(TM(itm->forwardPredictedState(),
-			    predTsos,
-			    smooTsos,
-			    preciseHit,
-			    estimate),
-			 estimator()->estimate(predTsos,*preciseHit).second);
-	//itm->estimate());
-      }
-    } else {
-      LogDebug("TrackFitters") 
-	<< "----------------- HIT #" << hitcounter << " (INVALID)-----------------------";      
-      
-      //no update
-      currTsos = predTsos;
-      TSOS combTsos;
-      if (hitcounter == avtm.size()) combTsos = itm->forwardPredictedState();
-      else if (hitcounter == 1) combTsos = predTsos;
-      else combTsos = combiner(predTsos, itm->forwardPredictedState());
-      
-      if unlikely(!combTsos.isValid()) {
-    	LogDebug("TrackFitters") << 
-    	  "KFTrajectorySmoother: combined tsos not valid!";
-        return Trajectory();
-	}
-      
-      myTraj.push(TM(itm->forwardPredictedState(),
-		     predTsos,
-    		     combTsos,
-    		     hit,
-		     0,
-		     theGeometry->idToLayer(hit->geographicalId()) ));
-    }
-  } // for loop
-  
-  return ret; 
-  
-}
